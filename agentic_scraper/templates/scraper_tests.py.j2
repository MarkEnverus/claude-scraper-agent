"""Tests for {{ source }} {{ data_type }} collector.

This test suite covers:
- Collector initialization
- Candidate generation
- Content collection
- Content validation
- CLI interface
- Integration tests (optional, requires credentials)
"""

import os
import json
from datetime import date, datetime
from pathlib import Path
from unittest.mock import Mock, patch, MagicMock

import pytest
import requests

from {{ filename.replace('.py', '') }} import (
    {{ class_name }},
    ENDPOINTS,
)
from sourcing.commons.collection_framework import DownloadCandidate


# ============================================================================
# FIXTURES
# ============================================================================

@pytest.fixture
def mock_redis():
    """Mock Redis client."""
    redis_mock = Mock()
    redis_mock.get.return_value = None  # No hash exists
    redis_mock.setex.return_value = True
    return redis_mock


@pytest.fixture
def collector(mock_redis):
    """Create {{ source }} collector instance with mocked dependencies."""
    with patch("sourcing.commons.s3_utils.boto3"):
        return {{ class_name }}(
            dgroup="{{ dgroup }}",
            s3_bucket="test-bucket",
            s3_prefix="sourcing",
            redis_client=mock_redis,
            environment="dev",
            kafka_connection_string=None,
{% if auth_required %}
            api_key="TEST_API_KEY",
{% endif %}
        )


@pytest.fixture
def sample_candidate():
    """Create sample DownloadCandidate."""
    return DownloadCandidate(
        identifier="{{ source_snake }}_{{ data_type_snake }}_test_20250101.{{ data_format }}",
        source_location="{{ api_base_url }}{{ endpoints[0].path }}",
        metadata={
            "source": "{{ source_lower }}",
            "data_type": "{{ data_type_lower }}",
            "endpoint": "{{ endpoints[0].name }}",
            "date": "2025-01-01",
            "dgroup": "{{ dgroup }}",
        },
        collection_params={
            "headers": {},
            "timeout": {{ timeout_seconds }},
        },
        file_date=date(2025, 1, 1),
    )


@pytest.fixture
def sample_{{ data_format }}_response():
    """Sample {{ data_format | upper }} response from API."""
{% if data_format == "json" %}
    return {
        "data": [
            {
                "timestamp": "2025-01-01T00:00:00Z",
                "value": 123.45,
            }
        ],
        "meta": {
            "source": "{{ source }}",
            "date": "2025-01-01",
        },
    }
{% elif data_format == "csv" %}
    return """timestamp,value
2025-01-01T00:00:00Z,123.45
2025-01-01T01:00:00Z,234.56
"""
{% elif data_format == "xml" %}
    return """<?xml version="1.0" encoding="UTF-8"?>
<data>
    <record>
        <timestamp>2025-01-01T00:00:00Z</timestamp>
        <value>123.45</value>
    </record>
</data>
"""
{% endif %}


# ============================================================================
# INITIALIZATION TESTS
# ============================================================================

def test_collector_initialization(collector):
    """Test collector initializes correctly."""
    assert collector.base_url == "{{ api_base_url }}"
    assert collector.dgroup == "{{ dgroup }}"
    assert len(collector.endpoints) == {{ endpoints | length }}
    assert collector.timeout == {{ timeout_seconds }}
    assert collector.retry_attempts == {{ retry_attempts }}


def test_collector_missing_api_key():
    """Test collector raises error without API key."""
{% if auth_required %}
    with pytest.raises(ValueError, match="API key required"):
        with patch("sourcing.commons.s3_utils.boto3"):
            {{ class_name }}(
                dgroup="{{ dgroup }}",
                s3_bucket="test-bucket",
                s3_prefix="sourcing",
                redis_client=Mock(),
                environment="dev",
                api_key=None,
            )
{% else %}
    # No authentication required, should not raise
    with patch("sourcing.commons.s3_utils.boto3"):
        collector = {{ class_name }}(
            dgroup="{{ dgroup }}",
            s3_bucket="test-bucket",
            s3_prefix="sourcing",
            redis_client=Mock(),
            environment="dev",
        )
    assert collector.auth_headers == {}
{% endif %}


def test_endpoint_configuration():
    """Test endpoint configuration is correct."""
    assert len(ENDPOINTS) == {{ endpoints | length }}

{% for endpoint in endpoints %}
    # {{ endpoint.display_name }}
    endpoint_{{ loop.index0 }} = ENDPOINTS[{{ loop.index0 }}]
    assert endpoint_{{ loop.index0 }}["name"] == "{{ endpoint.name }}"
    assert endpoint_{{ loop.index0 }}["method"] == "{{ endpoint.method }}"
    assert endpoint_{{ loop.index0 }}["path"] == "{{ endpoint.path }}"
{% endfor %}


# ============================================================================
# CANDIDATE GENERATION TESTS
# ============================================================================

def test_generate_candidates_single_day(collector):
    """Test candidate generation for single day."""
    start_date = date(2025, 1, 1)
    end_date = date(2025, 1, 1)

    candidates = collector.generate_candidates(start_date, end_date)

    # Should generate one candidate per endpoint
    assert len(candidates) == {{ endpoints | length }}

    # Check first candidate
    candidate = candidates[0]
    assert isinstance(candidate, DownloadCandidate)
    assert candidate.metadata["source"] == "{{ source_lower }}"
    assert candidate.metadata["data_type"] == "{{ data_type_lower }}"
    assert candidate.metadata["date"] == "2025-01-01"


def test_generate_candidates_date_range(collector):
    """Test candidate generation for date range."""
    start_date = date(2025, 1, 1)
    end_date = date(2025, 1, 3)

    candidates = collector.generate_candidates(start_date, end_date)

    # Should generate candidates for 3 days Ã— N endpoints
    expected_count = 3 * {{ endpoints | length }}
    assert len(candidates) == expected_count


def test_build_url_with_date(collector):
    """Test URL building with date parameters."""
    endpoint = ENDPOINTS[0]
    target_date = date(2025, 1, 15)

    url = collector._build_url(endpoint, target_date)

    assert url.startswith("{{ api_base_url }}")
    # Check date formatting based on endpoint path
    if "{date}" in endpoint["path"]:
        assert "2025-01-15" in url
    if "{year}" in endpoint["path"]:
        assert "2025" in url


def test_generate_filename(collector):
    """Test filename generation."""
    endpoint_name = "{{ endpoints[0].name }}"
    target_date = date(2025, 1, 15)

    filename = collector._generate_filename(endpoint_name, target_date)

    assert filename.startswith("{{ source_snake }}_{{ data_type_snake }}")
    assert "20250115" in filename
    assert filename.endswith(".{{ data_format }}")


# ============================================================================
# CONTENT COLLECTION TESTS
# ============================================================================

@patch("requests.get")
def test_collect_content_success(mock_get, collector, sample_candidate, sample_{{ data_format }}_response):
    """Test successful content collection."""
    # Mock successful HTTP response
    mock_response = Mock()
    mock_response.status_code = 200
    mock_response.raise_for_status = Mock()
{% if data_format == "json" %}
    mock_response.json.return_value = sample_{{ data_format }}_response
    mock_response.content = json.dumps(sample_{{ data_format }}_response).encode()
{% else %}
    mock_response.text = sample_{{ data_format }}_response
    mock_response.content = sample_{{ data_format }}_response.encode()
{% endif %}
    mock_get.return_value = mock_response

    # Collect content
    content = collector.collect_content(sample_candidate)

    # Verify result - collect_content returns bytes
    assert isinstance(content, bytes)
    assert len(content) > 0


@patch("requests.get")
def test_collect_content_http_error(mock_get, collector, sample_candidate):
    """Test content collection with HTTP error."""
    from sourcing.exceptions import ScrapingError

    # Mock HTTP error
    mock_get.side_effect = requests.HTTPError("404 Not Found")

    # Collect content - should raise ScrapingError
    with pytest.raises(ScrapingError):
        collector.collect_content(sample_candidate)


@patch("requests.get")
def test_collect_content_timeout(mock_get, collector, sample_candidate):
    """Test content collection with timeout."""
    from sourcing.exceptions import ScrapingError

    # Mock timeout
    mock_get.side_effect = requests.Timeout("Request timed out")

    # Collect content - should raise ScrapingError
    with pytest.raises(ScrapingError):
        collector.collect_content(sample_candidate)


@patch("requests.get")
def test_collect_content_retry_logic(mock_get, collector, sample_candidate):
    """Test retry logic on transient errors."""
    # Mock transient error then success
    mock_response = Mock()
    mock_response.status_code = 200
    mock_response.raise_for_status = Mock()
    mock_response.content = b'{"data": []}'

    mock_get.side_effect = [
        requests.ConnectionError("Connection refused"),
        mock_response,
    ]

    # Collect content
    content = collector.collect_content(sample_candidate)

    # Verify retry worked
    assert mock_get.call_count == 2
    assert isinstance(content, bytes)


# ============================================================================
# CONTENT VALIDATION TESTS
# ============================================================================

def test_validate_content_valid_data(collector, sample_candidate, sample_{{ data_format }}_response):
    """Test validation with valid data."""
{% if data_format == "json" %}
    content_bytes = json.dumps(sample_{{ data_format }}_response).encode()
{% else %}
    content_bytes = sample_{{ data_format }}_response.encode()
{% endif %}

    # validate_content takes (bytes, DownloadCandidate) and returns bool
    is_valid = collector.validate_content(content_bytes, sample_candidate)

    assert isinstance(is_valid, bool)
    assert is_valid is True


def test_validate_content_empty_data(collector, sample_candidate):
    """Test validation with empty data."""
    content_bytes = b""

    is_valid = collector.validate_content(content_bytes, sample_candidate)

    assert is_valid is False


def test_validate_content_invalid_format(collector, sample_candidate):
    """Test validation with invalid data format."""
{% if data_format == "json" %}
    # Invalid JSON
    content_bytes = b"not valid json {"
{% elif data_format == "csv" %}
    # Empty CSV
    content_bytes = b""
{% elif data_format == "xml" %}
    # Invalid XML
    content_bytes = b"<unclosed"
{% endif %}

    is_valid = collector.validate_content(content_bytes, sample_candidate)

    assert is_valid is False


# ============================================================================
# CLI TESTS
# ============================================================================

def test_cli_required_parameters():
    """Test CLI requires start-date, end-date, s3-bucket."""
    from click.testing import CliRunner
    from {{ source_snake }}.{{ filename.replace('.py', '') }} import main

    runner = CliRunner()
    result = runner.invoke(main, [])

    # Should fail with missing required parameters
    assert result.exit_code != 0
    assert "start-date" in result.output or "Missing option" in result.output


def test_cli_environment_variables():
    """Test CLI reads from environment variables."""
    from click.testing import CliRunner
    from {{ source_snake }}.{{ filename.replace('.py', '') }} import main

    runner = CliRunner()
    with runner.isolated_filesystem():
        result = runner.invoke(
            main,
            [
                "--start-date", "2025-01-01",
                "--end-date", "2025-01-01",
                "--s3-bucket", "test-bucket",
            ],
            env={
                "{{ auth_env_var }}": "test_key",
                "REDIS_HOST": "localhost",
                "REDIS_PORT": "6379",
            },
        )

        # Should accept environment variables
        # (may fail on infrastructure, but should parse CLI args)
        assert "{{ auth_env_var }}" not in result.output or result.exit_code == 0


# ============================================================================
# INTEGRATION TESTS (OPTIONAL)
# ============================================================================

{% if auth_required %}
@pytest.mark.skipif(
    os.getenv("{{ auth_env_var }}") is None,
    reason="Requires {{ auth_env_var }} environment variable",
)
{% endif %}
@pytest.mark.integration
def test_integration_real_api_call():
    """Integration test with real API call.

    This test requires {% if auth_required %}valid credentials and {% endif %}network access.
{% if auth_required %}
    Set {{ auth_env_var }} environment variable to run.
{% endif %}
    """
    import redis

    # Use real infrastructure (or test infrastructure)
    redis_client = redis.Redis(host="localhost", port=6379, decode_responses=False)

    collector = {{ class_name }}(
        dgroup="{{ dgroup }}_test",
        s3_bucket=os.getenv("S3_BUCKET", "test-bucket"),
        s3_prefix=os.getenv("S3_PREFIX", "sourcing"),
        redis_client=redis_client,
        environment="dev",
        kafka_connection_string=None,
{% if auth_required %}
        api_key=os.getenv("{{ auth_env_var }}"),
{% endif %}
    )

    # Test with recent date
    start_date = date.today()
    end_date = date.today()

    candidates = collector.generate_candidates(start_date, end_date)
    assert len(candidates) > 0

    # Collect from first candidate
    candidate = candidates[0]
    content = collector.collect_content(candidate)

    # Verify successful collection - collect_content returns bytes
    assert isinstance(content, bytes)
    assert len(content) > 0

    # Validate content - validate_content returns bool
    is_valid = collector.validate_content(content, candidate)
    assert is_valid is True
