"""Tests for {{ source }} {{ data_type }} collector.

This test suite covers:
- Collector initialization
- Candidate generation
- Content collection
- Content validation
- CLI interface
- Integration tests (optional, requires credentials)
"""

import os
import json
from datetime import date, datetime
from pathlib import Path
from unittest.mock import Mock, patch, MagicMock

import pytest
import requests

from {{ filename.replace('.py', '') }} import (
    {{ class_name }},
    ENDPOINTS,
)
from sourcing.commons.collection_framework import (
    DownloadCandidate,
    CollectedContent,
    ValidationResult,
)


# ============================================================================
# FIXTURES
# ============================================================================

@pytest.fixture
def mock_redis():
    """Mock Redis client."""
    redis_mock = Mock()
    redis_mock.get.return_value = None  # No hash exists
    redis_mock.setex.return_value = True
    return redis_mock


@pytest.fixture
def mock_s3_manager():
    """Mock S3Manager."""
    s3_mock = Mock()
    s3_mock.upload_file.return_value = "s3://bucket/path/to/file"
    return s3_mock


@pytest.fixture
def mock_kafka_producer():
    """Mock KafkaProducer."""
    kafka_mock = Mock()
    kafka_mock.send.return_value = None
    return kafka_mock


@pytest.fixture
def collector(mock_redis, mock_s3_manager, mock_kafka_producer):
    """Create {{ source }} collector instance with mocked dependencies."""
    return {{ class_name }}(
        api_key="{{ auth_env_var }}_TEST_KEY",
        redis_client=mock_redis,
        s3_manager=mock_s3_manager,
        kafka_producer=mock_kafka_producer,
        dgroup="{{ dgroup }}",
    )


@pytest.fixture
def sample_candidate():
    """Create sample DownloadCandidate."""
    return DownloadCandidate(
        url="{{ api_base_url }}{{ endpoints[0].path }}",
        expected_filename="{{ source_snake }}_{{ data_type_snake }}_test_20250101.{{ data_format }}",
        metadata={
            "source": "{{ source_lower }}",
            "data_type": "{{ data_type_lower }}",
            "endpoint": "{{ endpoints[0].name }}",
            "date": "2025-01-01",
            "dgroup": "{{ dgroup }}",
        },
    )


@pytest.fixture
def sample_{{ data_format }}_response():
    """Sample {{ data_format | upper }} response from API."""
{% if data_format == "json" %}
    return {
        "data": [
            {
                "timestamp": "2025-01-01T00:00:00Z",
                "value": 123.45,
            }
        ],
        "meta": {
            "source": "{{ source }}",
            "date": "2025-01-01",
        },
    }
{% elif data_format == "csv" %}
    return """timestamp,value
2025-01-01T00:00:00Z,123.45
2025-01-01T01:00:00Z,234.56
"""
{% elif data_format == "xml" %}
    return """<?xml version="1.0" encoding="UTF-8"?>
<data>
    <record>
        <timestamp>2025-01-01T00:00:00Z</timestamp>
        <value>123.45</value>
    </record>
</data>
"""
{% endif %}


# ============================================================================
# INITIALIZATION TESTS
# ============================================================================

def test_collector_initialization(collector):
    """Test collector initializes correctly."""
    assert collector.base_url == "{{ api_base_url }}"
    assert collector.dgroup == "{{ dgroup }}"
    assert len(collector.endpoints) == {{ endpoints | length }}
    assert collector.timeout == {{ timeout_seconds }}
    assert collector.retry_attempts == {{ retry_attempts }}


def test_collector_missing_api_key():
    """Test collector raises error without API key."""
{% if auth_required %}
    with pytest.raises(ValueError, match="API key required"):
        {{ class_name }}(
            api_key=None,
            redis_client=Mock(),
            s3_manager=Mock(),
            kafka_producer=Mock(),
        )
{% else %}
    # No authentication required, should not raise
    collector = {{ class_name }}(
        api_key=None,
        redis_client=Mock(),
        s3_manager=Mock(),
        kafka_producer=Mock(),
    )
    assert collector.auth_headers == {}
{% endif %}


def test_endpoint_configuration():
    """Test endpoint configuration is correct."""
    assert len(ENDPOINTS) == {{ endpoints | length }}

{% for endpoint in endpoints %}
    # {{ endpoint.display_name }}
    endpoint_{{ loop.index0 }} = ENDPOINTS[{{ loop.index0 }}]
    assert endpoint_{{ loop.index0 }}["name"] == "{{ endpoint.name }}"
    assert endpoint_{{ loop.index0 }}["method"] == "{{ endpoint.method }}"
    assert endpoint_{{ loop.index0 }}["path"] == "{{ endpoint.path }}"
{% endfor %}


# ============================================================================
# CANDIDATE GENERATION TESTS
# ============================================================================

def test_generate_candidates_single_day(collector):
    """Test candidate generation for single day."""
    start_date = date(2025, 1, 1)
    end_date = date(2025, 1, 1)

    candidates = collector.generate_candidates(start_date, end_date)

    # Should generate one candidate per endpoint
    assert len(candidates) == {{ endpoints | length }}

    # Check first candidate
    candidate = candidates[0]
    assert isinstance(candidate, DownloadCandidate)
    assert candidate.metadata["source"] == "{{ source_lower }}"
    assert candidate.metadata["data_type"] == "{{ data_type_lower }}"
    assert candidate.metadata["date"] == "2025-01-01"


def test_generate_candidates_date_range(collector):
    """Test candidate generation for date range."""
    start_date = date(2025, 1, 1)
    end_date = date(2025, 1, 3)

    candidates = collector.generate_candidates(start_date, end_date)

    # Should generate candidates for 3 days Ã— N endpoints
    expected_count = 3 * {{ endpoints | length }}
    assert len(candidates) == expected_count


def test_build_url_with_date(collector):
    """Test URL building with date parameters."""
    endpoint = ENDPOINTS[0]
    target_date = date(2025, 1, 15)

    url = collector._build_url(endpoint, target_date)

    assert url.startswith("{{ api_base_url }}")
    # Check date formatting based on endpoint path
    if "{date}" in endpoint["path"]:
        assert "2025-01-15" in url
    if "{year}" in endpoint["path"]:
        assert "2025" in url


def test_generate_filename(collector):
    """Test filename generation."""
    endpoint_name = "{{ endpoints[0].name }}"
    target_date = date(2025, 1, 15)

    filename = collector._generate_filename(endpoint_name, target_date)

    assert filename.startswith("{{ source_snake }}_{{ data_type_snake }}")
    assert "20250115" in filename
    assert filename.endswith(".{{ data_format }}")


# ============================================================================
# CONTENT COLLECTION TESTS
# ============================================================================

@patch("requests.get")
def test_collect_content_success(mock_get, collector, sample_candidate, sample_{{ data_format }}_response):
    """Test successful content collection."""
    # Mock successful HTTP response
    mock_response = Mock()
    mock_response.status_code = 200
{% if data_format == "json" %}
    mock_response.json.return_value = sample_{{ data_format }}_response
    mock_response.content = json.dumps(sample_{{ data_format }}_response).encode()
{% else %}
    mock_response.text = sample_{{ data_format }}_response
    mock_response.content = sample_{{ data_format }}_response.encode()
{% endif %}
    mock_get.return_value = mock_response

    # Collect content
    content = collector.collect_content(sample_candidate)

    # Verify result
    assert isinstance(content, CollectedContent)
    assert content.success is True
    assert content.content is not None
    assert content.error_message is None


@patch("requests.get")
def test_collect_content_http_error(mock_get, collector, sample_candidate):
    """Test content collection with HTTP error."""
    # Mock HTTP error
    mock_get.side_effect = requests.HTTPError("404 Not Found")

    # Collect content
    content = collector.collect_content(sample_candidate)

    # Verify error handling
    assert isinstance(content, CollectedContent)
    assert content.success is False
    assert content.error_message is not None


@patch("requests.get")
def test_collect_content_timeout(mock_get, collector, sample_candidate):
    """Test content collection with timeout."""
    # Mock timeout
    mock_get.side_effect = requests.Timeout("Request timed out")

    # Collect content
    content = collector.collect_content(sample_candidate)

    # Verify error handling
    assert isinstance(content, CollectedContent)
    assert content.success is False
    assert "timeout" in content.error_message.lower()


@patch("requests.get")
def test_collect_content_retry_logic(mock_get, collector, sample_candidate):
    """Test retry logic on transient errors."""
    # Mock transient error then success
    mock_get.side_effect = [
        requests.ConnectionError("Connection refused"),
        Mock(status_code=200, content=b'{"data": []}'),
    ]

    # Collect content
    content = collector.collect_content(sample_candidate)

    # Verify retry worked
    assert mock_get.call_count == 2
    assert content.success is True


# ============================================================================
# CONTENT VALIDATION TESTS
# ============================================================================

def test_validate_content_valid_data(collector, sample_candidate, sample_{{ data_format }}_response):
    """Test validation with valid data."""
{% if data_format == "json" %}
    content_bytes = json.dumps(sample_{{ data_format }}_response).encode()
{% else %}
    content_bytes = sample_{{ data_format }}_response.encode()
{% endif %}

    content = CollectedContent(
        candidate=sample_candidate,
        success=True,
        content=content_bytes,
        content_hash="abc123",
    )

    result = collector.validate_content(content)

    assert isinstance(result, ValidationResult)
    assert result.is_valid is True
    assert len(result.errors) == 0


def test_validate_content_empty_data(collector, sample_candidate):
    """Test validation with empty data."""
    content = CollectedContent(
        candidate=sample_candidate,
        success=True,
        content=b"",
        content_hash="",
    )

    result = collector.validate_content(content)

    assert result.is_valid is False
    assert len(result.errors) > 0


def test_validate_content_invalid_format(collector, sample_candidate):
    """Test validation with invalid data format."""
{% if data_format == "json" %}
    # Invalid JSON
    content_bytes = b"not valid json {"
{% elif data_format == "csv" %}
    # Empty CSV
    content_bytes = b""
{% elif data_format == "xml" %}
    # Invalid XML
    content_bytes = b"<unclosed"
{% endif %}

    content = CollectedContent(
        candidate=sample_candidate,
        success=True,
        content=content_bytes,
        content_hash="abc123",
    )

    result = collector.validate_content(content)

    assert result.is_valid is False


# ============================================================================
# CLI TESTS
# ============================================================================

def test_cli_required_parameters():
    """Test CLI requires start-date, end-date, s3-bucket."""
    from click.testing import CliRunner
    from {{ source_snake }}.{{ filename.replace('.py', '') }} import main

    runner = CliRunner()
    result = runner.invoke(main, [])

    # Should fail with missing required parameters
    assert result.exit_code != 0
    assert "start-date" in result.output or "Missing option" in result.output


def test_cli_environment_variables():
    """Test CLI reads from environment variables."""
    from click.testing import CliRunner
    from {{ source_snake }}.{{ filename.replace('.py', '') }} import main

    runner = CliRunner()
    with runner.isolated_filesystem():
        result = runner.invoke(
            main,
            [
                "--start-date", "2025-01-01",
                "--end-date", "2025-01-01",
                "--s3-bucket", "test-bucket",
            ],
            env={
                "{{ auth_env_var }}": "test_key",
                "REDIS_HOST": "localhost",
                "REDIS_PORT": "6379",
            },
        )

        # Should accept environment variables
        # (may fail on infrastructure, but should parse CLI args)
        assert "{{ auth_env_var }}" not in result.output or result.exit_code == 0


# ============================================================================
# INTEGRATION TESTS (OPTIONAL)
# ============================================================================

@pytest.mark.skipif(
    os.getenv("{{ auth_env_var }}") is None,
    reason="Requires {{ auth_env_var }} environment variable",
)
@pytest.mark.integration
def test_integration_real_api_call():
    """Integration test with real API call.

    This test requires valid credentials and network access.
    Set {{ auth_env_var }} environment variable to run.
    """
    import redis

    # Use real infrastructure (or test infrastructure)
    redis_client = redis.Redis(host="localhost", port=6379, decode_responses=False)
    s3_manager = Mock()  # Mock S3 for integration test
    kafka_producer = None

    collector = {{ class_name }}(
        api_key=os.getenv("{{ auth_env_var }}"),
        redis_client=redis_client,
        s3_manager=s3_manager,
        kafka_producer=kafka_producer,
        dgroup="{{ dgroup }}_test",
    )

    # Test with recent date
    start_date = date.today()
    end_date = date.today()

    candidates = collector.generate_candidates(start_date, end_date)
    assert len(candidates) > 0

    # Collect from first candidate
    candidate = candidates[0]
    content = collector.collect_content(candidate)

    # Verify successful collection
    assert content.success is True
    assert content.content is not None

    # Validate content
    validation = collector.validate_content(content)
    assert validation.is_valid is True
