/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import type { Image, Audio, Pdf, Video } from "@boundaryml/baml"
/**
 * Recursively partial type that can be null.
 *
 * @deprecated Use types from the `partial_types` namespace instead, which provides type-safe partial implementations
 * @template T The type to make recursively partial.
 */
export type RecursivePartialNull<T> = T extends object
    ? { [P in keyof T]?: RecursivePartialNull<T[P]> }
    : T | null;

export interface Checked<T,CheckName extends string = string> {
    value: T,
    checks: Record<CheckName, Check>,
}

export interface Check {
    name: string,
    expr: string
    status: "succeeded" | "failed"
}

export function all_succeeded<CheckName extends string>(checks: Record<CheckName, Check>): boolean {
    return get_checks(checks).every(check => check.status === "succeeded")
}

export function get_checks<CheckName extends string>(checks: Record<CheckName, Check>): Check[] {
    return Object.values(checks)
}
export enum AuthenticationMethod {
  NONE = "NONE",
  API_KEY = "API_KEY",
  BEARER_TOKEN = "BEARER_TOKEN",
  OAUTH = "OAUTH",
  BASIC_AUTH = "BASIC_AUTH",
  COOKIE = "COOKIE",
  UNKNOWN = "UNKNOWN",
}

export enum ComplexityLevel {
  LOW = "LOW",
  MEDIUM = "MEDIUM",
  HIGH = "HIGH",
}

export enum ConfidenceLevel {
  HIGH = "HIGH",
  MEDIUM = "MEDIUM",
  LOW = "LOW",
}

export enum DataSourceType {
  API = "API",
  FTP = "FTP",
  WEBSITE = "WEBSITE",
  EMAIL = "EMAIL",
}

export enum ExtractionQuality {
  COMPREHENSIVE = "COMPREHENSIVE",
  PARTIAL = "PARTIAL",
  LIMITED = "LIMITED",
  MISSING = "MISSING",
}

export enum HTTPMethod {
  GET = "GET",
  POST = "POST",
  PUT = "PUT",
  DELETE = "DELETE",
  PATCH = "PATCH",
  HEAD = "HEAD",
  OPTIONS = "OPTIONS",
}

export enum ScraperType {
  WEBSITE_PARSER = "WEBSITE_PARSER",
  HTTP_COLLECTOR = "HTTP_COLLECTOR",
  API_CLIENT = "API_CLIENT",
  FTP_CLIENT = "FTP_CLIENT",
}

export enum ValidationOverallStatus {
  PASS = "PASS",
  NEEDS_IMPROVEMENT = "NEEDS_IMPROVEMENT",
  FAIL = "FAIL",
}

export enum ValidationStatus {
  TESTED_200_OK = "TESTED_200_OK",
  TESTED_401_UNAUTHORIZED = "TESTED_401_UNAUTHORIZED",
  TESTED_403_FORBIDDEN = "TESTED_403_FORBIDDEN",
  TESTED_404_NOT_FOUND = "TESTED_404_NOT_FOUND",
  NOT_TESTED = "NOT_TESTED",
}

export interface AccessRequirements {
  authentication: string
  registration?: Record<string, string> | null
  terms_of_use_url?: string | null
  subscription_required: boolean
  rate_limits: string
  
}

export interface AuthClaims {
  auth_section_found: boolean
  auth_section_text?: string | null
  signup_links: string[]
  api_key_mentioned: boolean
  subscription_mentioned: boolean
  auth_header_examples: string[]
  conclusion: string
  
}

export interface AuthenticationFindings {
  auth_required: boolean
  evidence: string
  cookie_required: boolean
  redirect_to_login: boolean
  auth_headers_found: string[]
  
}

export interface AuthenticationSpec {
  required: boolean
  method: AuthenticationMethod
  header_name?: string | null
  evidence: string
  registration_url?: string | null
  notes: string
  authentication_consistency?: boolean | null
  authentication_notes?: string | null
  authentication_details?: string | null
  
}

export interface CollationAnalysis {
  run_comparison: Record<string, string>
  improvements_from_run2: string[]
  discrepancies_resolved: Record<string, string>[]
  consistency_checks: Record<string, string>
  
}

export interface CollationMetadata {
  collation_timestamp: string
  run1_timestamp: string
  run2_timestamp: string
  validation_report: string
  runs_compared: number
  collation_agent: string
  
}

export interface CollationResult {
  collation_complete: boolean
  final_spec_path: string
  final_confidence_score: number
  total_endpoints: number
  endpoints_run1: number
  endpoints_run2: number
  improvements_count: number
  discrepancies_resolved: number
  consistency_rate: string
  ready_for_scraper_generation: boolean
  
}

export interface CriticalGap {
  gap_type: string
  description: string
  action_required: string
  discovered?: number | null
  documented?: number | null
  missing?: number | null
  
}

export interface DataCatalog {
  total_files_discovered: number
  total_endpoints: number
  file_formats: Record<string, number>
  data_categories: string[]
  downloadable_files: Record<string, string>[]
  
}

export interface DataInventory {
  total_files: number
  file_formats: string[]
  categories: string[]
  download_links: Record<string, string>[]
  
}

export interface Discrepancy {
  type: string
  documentation_said?: string | null
  api_testing_showed?: string | null
  severity: string
  resolution: string
  area?: string | null
  phase1_claim?: string | null
  phase2_finding?: string | null
  
}

export interface DownloadTest {
  url: string
  http_status: number
  content_type?: string | null
  content_length?: string | null
  last_modified?: string | null
  accessible: boolean
  requires_auth: boolean
  redirect_to_login?: boolean | null
  
}

export interface Endpoint {
  path: string
  method: HTTPMethod
  parameters: Parameter[]
  auth_required: boolean
  response_format: string
  
}

export interface EndpointDetails {
  endpoint_id: string
  name: string
  type: string
  base_url: string
  path: string
  method: HTTPMethod
  parameters: Record<string, Parameter>
  authentication: Record<string, string>
  response_format: string
  data_structure?: Record<string, string> | null
  sample_files?: Record<string, string>[] | null
  validation_status: ValidationStatus
  accessible: boolean
  last_tested: string
  file_count?: number | null
  update_frequency?: string | null
  notes: string
  validation_consistency?: string | null
  tested_in_run1?: boolean | null
  tested_in_run2?: boolean | null
  
}

export interface EndpointDiscovery {
  total_endpoints_found: number
  collapsible_sections_expanded: number
  extraction_method: string
  screenshot_taken: boolean
  systematic_enumeration_completed: boolean
  
}

export interface EndpointSpec {
  endpoint_id: string
  path: string
  method: HTTPMethod
  description: string
  parameters: Parameter[]
  response_format: string
  authentication_mentioned: boolean
  
}

export interface ExecutiveSummary {
  total_endpoints_discovered: number
  total_datasets?: number | null
  total_files?: number | null
  accessible_endpoints: number
  protected_endpoints?: number | null
  broken_endpoints?: number | null
  success_rate: string
  primary_formats: string[]
  authentication_required: boolean
  estimated_scraper_complexity: ComplexityLevel
  improvements_from_run1?: Record<string, string> | null
  
}

export interface FileMetadataVerification {
  file_sizes_match_claims: string
  content_types_match: boolean
  last_modified_dates_available: boolean
  
}

export interface Parameter {
  name: string
  type: string
  required: boolean
  description: string
  example?: string | null
  
}

export interface Phase0Detection {
  detected_type: DataSourceType
  confidence: number
  indicators: string[]
  discovered_api_calls: string[]
  endpoints: Endpoint[]
  url: string
  fallback_strategy?: string | null
  
}

export interface Phase1Documentation {
  source: string
  timestamp: string
  url: string
  endpoint_discovery?: EndpointDiscovery | null
  auth_claims?: AuthClaims | null
  endpoints: EndpointSpec[]
  doc_quality: string
  notes: string
  source_type?: string | null
  data_inventory?: DataInventory | null
  access_requirements?: AccessRequirements | null
  update_frequency?: string | null
  portal_type?: string | null
  extraction_quality?: ExtractionQuality | null
  
}

export interface Phase2Tests {
  source: string
  timestamp: string
  endpoint_tested?: string | null
  test_results?: Record<string, TestResult> | null
  conclusion?: TestConclusion | null
  files_saved: string[]
  source_type?: string | null
  download_tests?: Record<string, DownloadTest[]> | null
  authentication_findings?: AuthenticationFindings | null
  file_metadata_verification?: FileMetadataVerification | null
  
}

export interface PhaseValidation {
  status: ValidationOverallStatus
  issues: Record<string, string>[]
  notes: string
  
}

export interface ScraperRecommendation {
  type: ScraperType
  confidence?: ConfidenceLevel | null
  rationale: string[]
  complexity: ComplexityLevel
  estimated_effort: string
  key_challenges: string[]
  
}

export interface TestConclusion {
  auth_required: boolean
  evidence: string
  likely_auth_method: AuthenticationMethod
  likely_header_name?: string | null
  confidence: ConfidenceLevel
  
}

export interface TestResult {
  http_status: number
  response_snippet: string
  auth_keywords_found: string[]
  full_output_file: string
  
}

export interface ValidatedSpec {
  source: string
  source_type: string
  timestamp: string
  url: string
  executive_summary: ExecutiveSummary
  validation_summary: ValidationSummary
  authentication?: AuthenticationSpec | null
  access_requirements?: AccessRequirements | null
  endpoints: EndpointDetails[]
  data_catalog?: DataCatalog | null
  scraper_recommendation: ScraperRecommendation
  discrepancies: Discrepancy[]
  artifacts_generated: string[]
  next_steps: string[]
  collation_metadata?: CollationMetadata | null
  collation_analysis?: CollationAnalysis | null
  
}

export interface ValidationReport {
  validation_timestamp: string
  input_file: string
  overall_status: ValidationOverallStatus
  overall_confidence: number
  phase_validations: Record<string, PhaseValidation>
  critical_gaps: CriticalGap[]
  recommendations_for_second_pass: string[]
  validation_summary: string
  
}

export interface ValidationSummary {
  phases_completed: string[]
  documentation_review: string
  live_api_testing: string
  discrepancies_found: number
  confidence_score: number
  confidence_level: ConfidenceLevel
  recommendation: string
  collation_complete?: boolean | null
  runs_analyzed?: number | null
  final_confidence_score?: number | null
  run1_confidence?: number | null
  run2_confidence?: number | null
  confidence_consistency?: string | null
  validator_status?: string | null
  discrepancies_resolved?: number | null
  
}
