# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
import typing_extensions
from enum import Enum


from pydantic import BaseModel, ConfigDict


import baml_py

CheckT = typing_extensions.TypeVar('CheckT')
CheckName = typing_extensions.TypeVar('CheckName', bound=str)

class Check(BaseModel):
    name: str
    expression: str
    status: str
class Checked(BaseModel, typing.Generic[CheckT, CheckName]):
    value: CheckT
    checks: typing.Dict[CheckName, Check]

def get_checks(checks: typing.Dict[CheckName, Check]) -> typing.List[Check]:
    return list(checks.values())

def all_succeeded(checks: typing.Dict[CheckName, Check]) -> bool:
    return all(check.status == "succeeded" for check in get_checks(checks))
# #########################################################################
# Generated enums (13)
# #########################################################################

class AuthenticationMethod(str, Enum):
    NONE = "NONE"
    API_KEY = "API_KEY"
    BEARER_TOKEN = "BEARER_TOKEN"
    OAUTH = "OAUTH"
    BASIC_AUTH = "BASIC_AUTH"
    COOKIE = "COOKIE"
    UNKNOWN = "UNKNOWN"

class ComplexityLevel(str, Enum):
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"

class ConfidenceLevel(str, Enum):
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"

class DataSourceType(str, Enum):
    API = "API"
    FTP = "FTP"
    WEBSITE = "WEBSITE"
    EMAIL = "EMAIL"

class DocQuality(str, Enum):
    EXCELLENT = "EXCELLENT"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    POOR = "POOR"

class ExtractionQuality(str, Enum):
    COMPREHENSIVE = "COMPREHENSIVE"
    PARTIAL = "PARTIAL"
    LIMITED = "LIMITED"
    MISSING = "MISSING"

class HTTPMethod(str, Enum):
    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    DELETE = "DELETE"
    PATCH = "PATCH"
    HEAD = "HEAD"
    OPTIONS = "OPTIONS"

class ParameterLocation(str, Enum):
    PATH = "PATH"
    QUERY = "QUERY"
    HEADER = "HEADER"
    BODY = "BODY"
    COOKIE = "COOKIE"
    MATRIX = "MATRIX"

class PortalType(str, Enum):
    STATIC = "STATIC"
    SPA = "SPA"
    API_DOCS = "API_DOCS"
    CUSTOM_FRAMEWORK = "CUSTOM_FRAMEWORK"

class ResponseFormat(str, Enum):
    JSON = "JSON"
    XML = "XML"
    CSV = "CSV"
    HTML = "HTML"
    BINARY = "BINARY"

class ScraperType(str, Enum):
    WEBSITE_PARSER = "WEBSITE_PARSER"
    HTTP_COLLECTOR = "HTTP_COLLECTOR"
    API_CLIENT = "API_CLIENT"
    FTP_CLIENT = "FTP_CLIENT"

class ValidationOverallStatus(str, Enum):
    PASS = "PASS"
    NEEDS_IMPROVEMENT = "NEEDS_IMPROVEMENT"
    FAIL = "FAIL"

class ValidationStatus(str, Enum):
    TESTED_200_OK = "TESTED_200_OK"
    TESTED_401_UNAUTHORIZED = "TESTED_401_UNAUTHORIZED"
    TESTED_403_FORBIDDEN = "TESTED_403_FORBIDDEN"
    TESTED_404_NOT_FOUND = "TESTED_404_NOT_FOUND"
    NOT_TESTED = "NOT_TESTED"

# #########################################################################
# Generated classes (32)
# #########################################################################

class AccessRequirements(BaseModel):
    authentication: str
    registration: typing.Optional[typing.Dict[str, str]] = None
    terms_of_use_url: typing.Optional[str] = None
    subscription_required: bool
    rate_limits: str

class AuthClaims(BaseModel):
    auth_section_found: bool
    auth_section_text: typing.Optional[str] = None
    signup_links: typing.List[str]
    api_key_mentioned: bool
    subscription_mentioned: bool
    auth_header_examples: typing.List[str]
    conclusion: str

class AuthenticationFindings(BaseModel):
    auth_required: bool
    evidence: str
    cookie_required: bool
    redirect_to_login: bool
    auth_headers_found: typing.List[str]

class AuthenticationSpec(BaseModel):
    required: bool
    method: AuthenticationMethod
    header_name: typing.Optional[str] = None
    evidence: str
    registration_url: typing.Optional[str] = None
    notes: str
    authentication_consistency: typing.Optional[bool] = None
    authentication_notes: typing.Optional[str] = None
    authentication_details: typing.Optional[str] = None

class CollationAnalysis(BaseModel):
    run_comparison: typing.Dict[str, str]
    improvements_from_run2: typing.List[str]
    discrepancies_resolved: typing.List[typing.Dict[str, str]]
    consistency_checks: typing.Dict[str, str]

class CollationMetadata(BaseModel):
    collation_timestamp: str
    run1_timestamp: str
    run2_timestamp: str
    validation_report: str
    runs_compared: int
    collation_agent: str

class CollationResult(BaseModel):
    collation_complete: bool
    final_spec_path: str
    final_confidence_score: float
    total_endpoints: int
    endpoints_run1: int
    endpoints_run2: int
    improvements_count: int
    discrepancies_resolved: int
    consistency_rate: str
    ready_for_scraper_generation: bool

class CriticalGap(BaseModel):
    gap_type: str
    description: str
    action_required: str
    discovered: typing.Optional[int] = None
    documented: typing.Optional[int] = None
    missing: typing.Optional[int] = None

class DataCatalog(BaseModel):
    total_files_discovered: int
    total_endpoints: int
    file_formats: typing.Dict[str, int]
    data_categories: typing.List[str]
    downloadable_files: typing.List[typing.Dict[str, str]]

class DataInventory(BaseModel):
    total_files: int
    file_formats: typing.List[str]
    categories: typing.List[str]
    download_links: typing.List[typing.Dict[str, str]]

class Discrepancy(BaseModel):
    type: str
    documentation_said: typing.Optional[str] = None
    api_testing_showed: typing.Optional[str] = None
    severity: str
    resolution: str
    area: typing.Optional[str] = None
    phase1_claim: typing.Optional[str] = None
    phase2_finding: typing.Optional[str] = None

class DownloadTest(BaseModel):
    url: str
    http_status: int
    content_type: typing.Optional[str] = None
    content_length: typing.Optional[str] = None
    last_modified: typing.Optional[str] = None
    accessible: bool
    requires_auth: bool
    redirect_to_login: typing.Optional[bool] = None

class Endpoint(BaseModel):
    path: str
    method: HTTPMethod
    parameters: typing.List["Parameter"]
    auth_required: bool
    response_format: ResponseFormat

class EndpointDetails(BaseModel):
    endpoint_id: str
    name: str
    type: str
    base_url: str
    path: str
    method: HTTPMethod
    parameters: typing.Dict[str, "Parameter"]
    authentication: typing.Dict[str, str]
    response_format: ResponseFormat
    data_structure: typing.Optional[typing.Dict[str, str]] = None
    sample_files: typing.Optional[typing.List[typing.Dict[str, str]]] = None
    validation_status: ValidationStatus
    accessible: bool
    last_tested: str
    file_count: typing.Optional[int] = None
    update_frequency: typing.Optional[str] = None
    notes: str
    validation_consistency: typing.Optional[str] = None
    tested_in_run1: typing.Optional[bool] = None
    tested_in_run2: typing.Optional[bool] = None

class EndpointDiscovery(BaseModel):
    total_endpoints_found: int
    collapsible_sections_expanded: int
    extraction_method: str
    screenshot_taken: bool
    systematic_enumeration_completed: bool

class EndpointSpec(BaseModel):
    endpoint_id: str
    path: str
    method: HTTPMethod
    description: str
    parameters: typing.List["Parameter"]
    response_format: ResponseFormat
    authentication_mentioned: bool

class ExecutiveSummary(BaseModel):
    total_endpoints_discovered: int
    total_datasets: typing.Optional[int] = None
    total_files: typing.Optional[int] = None
    accessible_endpoints: int
    protected_endpoints: typing.Optional[int] = None
    broken_endpoints: typing.Optional[int] = None
    success_rate: str
    primary_formats: typing.List[str]
    authentication_required: bool
    estimated_scraper_complexity: ComplexityLevel
    improvements_from_run1: typing.Optional[typing.Dict[str, str]] = None

class FileMetadataVerification(BaseModel):
    file_sizes_match_claims: str
    content_types_match: bool
    last_modified_dates_available: bool

class GeneratedCode(BaseModel):
    code: str
    imports: typing.List[str]
    notes: str

class Parameter(BaseModel):
    name: str
    type: str
    required: bool
    description: str
    example: typing.Optional[str] = None

class Phase0Detection(BaseModel):
    detected_type: DataSourceType
    confidence: float
    indicators: typing.List[str]
    discovered_api_calls: typing.List[str]
    endpoints: typing.List["Endpoint"]
    url: str
    fallback_strategy: typing.Optional[str] = None

class Phase1Documentation(BaseModel):
    source: str
    timestamp: str
    url: str
    endpoint_discovery: typing.Optional["EndpointDiscovery"] = None
    auth_claims: typing.Optional["AuthClaims"] = None
    endpoints: typing.List["EndpointSpec"]
    doc_quality: DocQuality
    notes: str
    source_type: typing.Optional[str] = None
    data_inventory: typing.Optional["DataInventory"] = None
    access_requirements: typing.Optional["AccessRequirements"] = None
    update_frequency: typing.Optional[str] = None
    portal_type: typing.Optional[PortalType] = None
    extraction_quality: typing.Optional[ExtractionQuality] = None

class Phase2Tests(BaseModel):
    source: str
    timestamp: str
    endpoint_tested: typing.Optional[str] = None
    test_results: typing.Optional[typing.Dict[str, "TestResult"]] = None
    conclusion: typing.Optional["TestConclusion"] = None
    files_saved: typing.List[str]
    source_type: typing.Optional[str] = None
    download_tests: typing.Optional[typing.Dict[str, typing.List["DownloadTest"]]] = None
    authentication_findings: typing.Optional["AuthenticationFindings"] = None
    file_metadata_verification: typing.Optional["FileMetadataVerification"] = None
    portal_type: typing.Optional[PortalType] = None
    portal_conclusion: typing.Optional[str] = None

class PhaseValidation(BaseModel):
    status: ValidationOverallStatus
    issues: typing.List[typing.Dict[str, str]]
    notes: str

class ScraperRecommendation(BaseModel):
    type: ScraperType
    confidence: typing.Optional[ConfidenceLevel] = None
    rationale: typing.List[str]
    complexity: ComplexityLevel
    estimated_effort: str
    key_challenges: typing.List[str]

class TestConclusion(BaseModel):
    auth_required: bool
    evidence: str
    likely_auth_method: AuthenticationMethod
    likely_header_name: typing.Optional[str] = None
    confidence: ConfidenceLevel

class TestResult(BaseModel):
    http_status: int
    response_snippet: str
    auth_keywords_found: typing.List[str]
    full_output_file: str

class ValidatedSpec(BaseModel):
    source: str
    source_type: str
    timestamp: str
    url: str
    executive_summary: "ExecutiveSummary"
    validation_summary: "ValidationSummary"
    authentication: typing.Optional["AuthenticationSpec"] = None
    access_requirements: typing.Optional["AccessRequirements"] = None
    endpoints: typing.List["EndpointDetails"]
    data_catalog: typing.Optional["DataCatalog"] = None
    scraper_recommendation: "ScraperRecommendation"
    discrepancies: typing.List["Discrepancy"]
    artifacts_generated: typing.List[str]
    next_steps: typing.List[str]
    collation_metadata: typing.Optional["CollationMetadata"] = None
    collation_analysis: typing.Optional["CollationAnalysis"] = None

class ValidationReport(BaseModel):
    validation_timestamp: str
    input_file: str
    overall_status: ValidationOverallStatus
    overall_confidence: float
    phase_validations: typing.Dict[str, "PhaseValidation"]
    critical_gaps: typing.List["CriticalGap"]
    recommendations_for_second_pass: typing.List[str]
    validation_summary: str

class ValidationResult(BaseModel):
    confidence: float
    identified_gaps: typing.List[str]
    recommendations: typing.List[str]
    validation_notes: str

class ValidationRules(BaseModel):
    required_fields: typing.List[str]
    format_checks: typing.List[str]
    range_checks: typing.List[str]
    custom_logic: str

class ValidationSummary(BaseModel):
    phases_completed: typing.List[str]
    documentation_review: str
    live_api_testing: str
    discrepancies_found: int
    confidence_score: float
    confidence_level: ConfidenceLevel
    recommendation: str
    collation_complete: typing.Optional[bool] = None
    runs_analyzed: typing.Optional[int] = None
    final_confidence_score: typing.Optional[float] = None
    run1_confidence: typing.Optional[float] = None
    run2_confidence: typing.Optional[float] = None
    confidence_consistency: typing.Optional[str] = None
    validator_status: typing.Optional[str] = None
    discrepancies_resolved: typing.Optional[int] = None

# #########################################################################
# Generated type aliases (0)
# #########################################################################
