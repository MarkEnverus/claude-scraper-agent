# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
from baml_py import type_builder
from baml_py import baml_py
# These are exports, not used here, hence the linter is disabled
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder # noqa: F401 # pylint: disable=unused-import
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME

class TypeBuilder(type_builder.TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["AccessRequirements","AuthClaims","AuthenticationFindings","AuthenticationSpec","CollationAnalysis","CollationMetadata","CollationResult","CriticalGap","DataCatalog","DataInventory","Discrepancy","DownloadTest","Endpoint","EndpointDetails","EndpointDiscovery","EndpointSpec","ExecutiveSummary","FileMetadataVerification","Parameter","Phase0Detection","Phase1Documentation","Phase2Tests","PhaseValidation","ScraperRecommendation","TestConclusion","TestResult","ValidatedSpec","ValidationReport","ValidationResult","ValidationSummary",]
        ), enums=set(
          ["AuthenticationMethod","ComplexityLevel","ConfidenceLevel","DataSourceType","DocQuality","ExtractionQuality","HTTPMethod","ParameterLocation","PortalType","ResponseFormat","ScraperType","ValidationOverallStatus","ValidationStatus",]
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)

    # #########################################################################
    # Generated enums 13
    # #########################################################################

    @property
    def AuthenticationMethod(self) -> "AuthenticationMethodViewer":
        return AuthenticationMethodViewer(self)

    @property
    def ComplexityLevel(self) -> "ComplexityLevelViewer":
        return ComplexityLevelViewer(self)

    @property
    def ConfidenceLevel(self) -> "ConfidenceLevelViewer":
        return ConfidenceLevelViewer(self)

    @property
    def DataSourceType(self) -> "DataSourceTypeViewer":
        return DataSourceTypeViewer(self)

    @property
    def DocQuality(self) -> "DocQualityViewer":
        return DocQualityViewer(self)

    @property
    def ExtractionQuality(self) -> "ExtractionQualityViewer":
        return ExtractionQualityViewer(self)

    @property
    def HTTPMethod(self) -> "HTTPMethodViewer":
        return HTTPMethodViewer(self)

    @property
    def ParameterLocation(self) -> "ParameterLocationViewer":
        return ParameterLocationViewer(self)

    @property
    def PortalType(self) -> "PortalTypeViewer":
        return PortalTypeViewer(self)

    @property
    def ResponseFormat(self) -> "ResponseFormatViewer":
        return ResponseFormatViewer(self)

    @property
    def ScraperType(self) -> "ScraperTypeViewer":
        return ScraperTypeViewer(self)

    @property
    def ValidationOverallStatus(self) -> "ValidationOverallStatusViewer":
        return ValidationOverallStatusViewer(self)

    @property
    def ValidationStatus(self) -> "ValidationStatusViewer":
        return ValidationStatusViewer(self)


    # #########################################################################
    # Generated classes 30
    # #########################################################################

    @property
    def AccessRequirements(self) -> "AccessRequirementsViewer":
        return AccessRequirementsViewer(self)

    @property
    def AuthClaims(self) -> "AuthClaimsViewer":
        return AuthClaimsViewer(self)

    @property
    def AuthenticationFindings(self) -> "AuthenticationFindingsViewer":
        return AuthenticationFindingsViewer(self)

    @property
    def AuthenticationSpec(self) -> "AuthenticationSpecViewer":
        return AuthenticationSpecViewer(self)

    @property
    def CollationAnalysis(self) -> "CollationAnalysisViewer":
        return CollationAnalysisViewer(self)

    @property
    def CollationMetadata(self) -> "CollationMetadataViewer":
        return CollationMetadataViewer(self)

    @property
    def CollationResult(self) -> "CollationResultViewer":
        return CollationResultViewer(self)

    @property
    def CriticalGap(self) -> "CriticalGapViewer":
        return CriticalGapViewer(self)

    @property
    def DataCatalog(self) -> "DataCatalogViewer":
        return DataCatalogViewer(self)

    @property
    def DataInventory(self) -> "DataInventoryViewer":
        return DataInventoryViewer(self)

    @property
    def Discrepancy(self) -> "DiscrepancyViewer":
        return DiscrepancyViewer(self)

    @property
    def DownloadTest(self) -> "DownloadTestViewer":
        return DownloadTestViewer(self)

    @property
    def Endpoint(self) -> "EndpointViewer":
        return EndpointViewer(self)

    @property
    def EndpointDetails(self) -> "EndpointDetailsViewer":
        return EndpointDetailsViewer(self)

    @property
    def EndpointDiscovery(self) -> "EndpointDiscoveryViewer":
        return EndpointDiscoveryViewer(self)

    @property
    def EndpointSpec(self) -> "EndpointSpecViewer":
        return EndpointSpecViewer(self)

    @property
    def ExecutiveSummary(self) -> "ExecutiveSummaryViewer":
        return ExecutiveSummaryViewer(self)

    @property
    def FileMetadataVerification(self) -> "FileMetadataVerificationViewer":
        return FileMetadataVerificationViewer(self)

    @property
    def Parameter(self) -> "ParameterViewer":
        return ParameterViewer(self)

    @property
    def Phase0Detection(self) -> "Phase0DetectionViewer":
        return Phase0DetectionViewer(self)

    @property
    def Phase1Documentation(self) -> "Phase1DocumentationViewer":
        return Phase1DocumentationViewer(self)

    @property
    def Phase2Tests(self) -> "Phase2TestsViewer":
        return Phase2TestsViewer(self)

    @property
    def PhaseValidation(self) -> "PhaseValidationViewer":
        return PhaseValidationViewer(self)

    @property
    def ScraperRecommendation(self) -> "ScraperRecommendationViewer":
        return ScraperRecommendationViewer(self)

    @property
    def TestConclusion(self) -> "TestConclusionViewer":
        return TestConclusionViewer(self)

    @property
    def TestResult(self) -> "TestResultViewer":
        return TestResultViewer(self)

    @property
    def ValidatedSpec(self) -> "ValidatedSpecViewer":
        return ValidatedSpecViewer(self)

    @property
    def ValidationReport(self) -> "ValidationReportViewer":
        return ValidationReportViewer(self)

    @property
    def ValidationResult(self) -> "ValidationResultViewer":
        return ValidationResultViewer(self)

    @property
    def ValidationSummary(self) -> "ValidationSummaryViewer":
        return ValidationSummaryViewer(self)



# #########################################################################
# Generated enums 13
# #########################################################################

class AuthenticationMethodAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("AuthenticationMethod")
        self._values: typing.Set[str] = set([  "NONE",  "API_KEY",  "BEARER_TOKEN",  "OAUTH",  "BASIC_AUTH",  "COOKIE",  "UNKNOWN",  ])
        self._vals = AuthenticationMethodValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "AuthenticationMethodValues":
        return self._vals


class AuthenticationMethodViewer(AuthenticationMethodAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class AuthenticationMethodValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def NONE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NONE"))
    
    @property
    def API_KEY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("API_KEY"))
    
    @property
    def BEARER_TOKEN(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("BEARER_TOKEN"))
    
    @property
    def OAUTH(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OAUTH"))
    
    @property
    def BASIC_AUTH(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("BASIC_AUTH"))
    
    @property
    def COOKIE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COOKIE"))
    
    @property
    def UNKNOWN(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("UNKNOWN"))
    
    


class ComplexityLevelAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ComplexityLevel")
        self._values: typing.Set[str] = set([  "LOW",  "MEDIUM",  "HIGH",  ])
        self._vals = ComplexityLevelValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ComplexityLevelValues":
        return self._vals


class ComplexityLevelViewer(ComplexityLevelAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ComplexityLevelValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def LOW(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LOW"))
    
    @property
    def MEDIUM(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MEDIUM"))
    
    @property
    def HIGH(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HIGH"))
    
    


class ConfidenceLevelAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ConfidenceLevel")
        self._values: typing.Set[str] = set([  "HIGH",  "MEDIUM",  "LOW",  ])
        self._vals = ConfidenceLevelValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ConfidenceLevelValues":
        return self._vals


class ConfidenceLevelViewer(ConfidenceLevelAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ConfidenceLevelValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def HIGH(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HIGH"))
    
    @property
    def MEDIUM(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MEDIUM"))
    
    @property
    def LOW(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LOW"))
    
    


class DataSourceTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("DataSourceType")
        self._values: typing.Set[str] = set([  "API",  "FTP",  "WEBSITE",  "EMAIL",  ])
        self._vals = DataSourceTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "DataSourceTypeValues":
        return self._vals


class DataSourceTypeViewer(DataSourceTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class DataSourceTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def API(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("API"))
    
    @property
    def FTP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FTP"))
    
    @property
    def WEBSITE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("WEBSITE"))
    
    @property
    def EMAIL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EMAIL"))
    
    


class DocQualityAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("DocQuality")
        self._values: typing.Set[str] = set([  "EXCELLENT",  "HIGH",  "MEDIUM",  "LOW",  "POOR",  ])
        self._vals = DocQualityValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "DocQualityValues":
        return self._vals


class DocQualityViewer(DocQualityAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class DocQualityValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def EXCELLENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EXCELLENT"))
    
    @property
    def HIGH(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HIGH"))
    
    @property
    def MEDIUM(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MEDIUM"))
    
    @property
    def LOW(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LOW"))
    
    @property
    def POOR(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("POOR"))
    
    


class ExtractionQualityAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ExtractionQuality")
        self._values: typing.Set[str] = set([  "COMPREHENSIVE",  "PARTIAL",  "LIMITED",  "MISSING",  ])
        self._vals = ExtractionQualityValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ExtractionQualityValues":
        return self._vals


class ExtractionQualityViewer(ExtractionQualityAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ExtractionQualityValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def COMPREHENSIVE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMPREHENSIVE"))
    
    @property
    def PARTIAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PARTIAL"))
    
    @property
    def LIMITED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LIMITED"))
    
    @property
    def MISSING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MISSING"))
    
    


class HTTPMethodAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("HTTPMethod")
        self._values: typing.Set[str] = set([  "GET",  "POST",  "PUT",  "DELETE",  "PATCH",  "HEAD",  "OPTIONS",  ])
        self._vals = HTTPMethodValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "HTTPMethodValues":
        return self._vals


class HTTPMethodViewer(HTTPMethodAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class HTTPMethodValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def GET(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("GET"))
    
    @property
    def POST(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("POST"))
    
    @property
    def PUT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PUT"))
    
    @property
    def DELETE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DELETE"))
    
    @property
    def PATCH(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PATCH"))
    
    @property
    def HEAD(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HEAD"))
    
    @property
    def OPTIONS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OPTIONS"))
    
    


class ParameterLocationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ParameterLocation")
        self._values: typing.Set[str] = set([  "PATH",  "QUERY",  "HEADER",  "BODY",  "COOKIE",  "MATRIX",  ])
        self._vals = ParameterLocationValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ParameterLocationValues":
        return self._vals


class ParameterLocationViewer(ParameterLocationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ParameterLocationValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def PATH(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PATH"))
    
    @property
    def QUERY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("QUERY"))
    
    @property
    def HEADER(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HEADER"))
    
    @property
    def BODY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("BODY"))
    
    @property
    def COOKIE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COOKIE"))
    
    @property
    def MATRIX(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MATRIX"))
    
    


class PortalTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("PortalType")
        self._values: typing.Set[str] = set([  "STATIC",  "SPA",  "API_DOCS",  "CUSTOM_FRAMEWORK",  ])
        self._vals = PortalTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "PortalTypeValues":
        return self._vals


class PortalTypeViewer(PortalTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class PortalTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def STATIC(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("STATIC"))
    
    @property
    def SPA(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SPA"))
    
    @property
    def API_DOCS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("API_DOCS"))
    
    @property
    def CUSTOM_FRAMEWORK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CUSTOM_FRAMEWORK"))
    
    


class ResponseFormatAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ResponseFormat")
        self._values: typing.Set[str] = set([  "JSON",  "XML",  "CSV",  "HTML",  "BINARY",  ])
        self._vals = ResponseFormatValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ResponseFormatValues":
        return self._vals


class ResponseFormatViewer(ResponseFormatAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ResponseFormatValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def JSON(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("JSON"))
    
    @property
    def XML(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("XML"))
    
    @property
    def CSV(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CSV"))
    
    @property
    def HTML(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HTML"))
    
    @property
    def BINARY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("BINARY"))
    
    


class ScraperTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ScraperType")
        self._values: typing.Set[str] = set([  "WEBSITE_PARSER",  "HTTP_COLLECTOR",  "API_CLIENT",  "FTP_CLIENT",  ])
        self._vals = ScraperTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ScraperTypeValues":
        return self._vals


class ScraperTypeViewer(ScraperTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ScraperTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def WEBSITE_PARSER(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("WEBSITE_PARSER"))
    
    @property
    def HTTP_COLLECTOR(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HTTP_COLLECTOR"))
    
    @property
    def API_CLIENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("API_CLIENT"))
    
    @property
    def FTP_CLIENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FTP_CLIENT"))
    
    


class ValidationOverallStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ValidationOverallStatus")
        self._values: typing.Set[str] = set([  "PASS",  "NEEDS_IMPROVEMENT",  "FAIL",  ])
        self._vals = ValidationOverallStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ValidationOverallStatusValues":
        return self._vals


class ValidationOverallStatusViewer(ValidationOverallStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ValidationOverallStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def PASS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PASS"))
    
    @property
    def NEEDS_IMPROVEMENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NEEDS_IMPROVEMENT"))
    
    @property
    def FAIL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FAIL"))
    
    


class ValidationStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ValidationStatus")
        self._values: typing.Set[str] = set([  "TESTED_200_OK",  "TESTED_401_UNAUTHORIZED",  "TESTED_403_FORBIDDEN",  "TESTED_404_NOT_FOUND",  "NOT_TESTED",  ])
        self._vals = ValidationStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ValidationStatusValues":
        return self._vals


class ValidationStatusViewer(ValidationStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ValidationStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def TESTED_200_OK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TESTED_200_OK"))
    
    @property
    def TESTED_401_UNAUTHORIZED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TESTED_401_UNAUTHORIZED"))
    
    @property
    def TESTED_403_FORBIDDEN(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TESTED_403_FORBIDDEN"))
    
    @property
    def TESTED_404_NOT_FOUND(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TESTED_404_NOT_FOUND"))
    
    @property
    def NOT_TESTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NOT_TESTED"))
    
    



# #########################################################################
# Generated classes 30
# #########################################################################

class AccessRequirementsAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AccessRequirements")
        self._properties: typing.Set[str] = set([  "authentication",  "registration",  "terms_of_use_url",  "subscription_required",  "rate_limits",  ])
        self._props = AccessRequirementsProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AccessRequirementsProperties":
        return self._props


class AccessRequirementsViewer(AccessRequirementsAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AccessRequirementsProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def authentication(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authentication"))
    
    @property
    def registration(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("registration"))
    
    @property
    def terms_of_use_url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("terms_of_use_url"))
    
    @property
    def subscription_required(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("subscription_required"))
    
    @property
    def rate_limits(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("rate_limits"))
    
    


class AuthClaimsAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AuthClaims")
        self._properties: typing.Set[str] = set([  "auth_section_found",  "auth_section_text",  "signup_links",  "api_key_mentioned",  "subscription_mentioned",  "auth_header_examples",  "conclusion",  ])
        self._props = AuthClaimsProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AuthClaimsProperties":
        return self._props


class AuthClaimsViewer(AuthClaimsAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AuthClaimsProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def auth_section_found(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("auth_section_found"))
    
    @property
    def auth_section_text(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("auth_section_text"))
    
    @property
    def signup_links(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("signup_links"))
    
    @property
    def api_key_mentioned(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("api_key_mentioned"))
    
    @property
    def subscription_mentioned(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("subscription_mentioned"))
    
    @property
    def auth_header_examples(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("auth_header_examples"))
    
    @property
    def conclusion(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("conclusion"))
    
    


class AuthenticationFindingsAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AuthenticationFindings")
        self._properties: typing.Set[str] = set([  "auth_required",  "evidence",  "cookie_required",  "redirect_to_login",  "auth_headers_found",  ])
        self._props = AuthenticationFindingsProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AuthenticationFindingsProperties":
        return self._props


class AuthenticationFindingsViewer(AuthenticationFindingsAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AuthenticationFindingsProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def auth_required(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("auth_required"))
    
    @property
    def evidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("evidence"))
    
    @property
    def cookie_required(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cookie_required"))
    
    @property
    def redirect_to_login(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("redirect_to_login"))
    
    @property
    def auth_headers_found(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("auth_headers_found"))
    
    


class AuthenticationSpecAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AuthenticationSpec")
        self._properties: typing.Set[str] = set([  "required",  "method",  "header_name",  "evidence",  "registration_url",  "notes",  "authentication_consistency",  "authentication_notes",  "authentication_details",  ])
        self._props = AuthenticationSpecProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AuthenticationSpecProperties":
        return self._props


class AuthenticationSpecViewer(AuthenticationSpecAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AuthenticationSpecProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def required(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("required"))
    
    @property
    def method(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("method"))
    
    @property
    def header_name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("header_name"))
    
    @property
    def evidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("evidence"))
    
    @property
    def registration_url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("registration_url"))
    
    @property
    def notes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("notes"))
    
    @property
    def authentication_consistency(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authentication_consistency"))
    
    @property
    def authentication_notes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authentication_notes"))
    
    @property
    def authentication_details(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authentication_details"))
    
    


class CollationAnalysisAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CollationAnalysis")
        self._properties: typing.Set[str] = set([  "run_comparison",  "improvements_from_run2",  "discrepancies_resolved",  "consistency_checks",  ])
        self._props = CollationAnalysisProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CollationAnalysisProperties":
        return self._props


class CollationAnalysisViewer(CollationAnalysisAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CollationAnalysisProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def run_comparison(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("run_comparison"))
    
    @property
    def improvements_from_run2(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("improvements_from_run2"))
    
    @property
    def discrepancies_resolved(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("discrepancies_resolved"))
    
    @property
    def consistency_checks(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("consistency_checks"))
    
    


class CollationMetadataAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CollationMetadata")
        self._properties: typing.Set[str] = set([  "collation_timestamp",  "run1_timestamp",  "run2_timestamp",  "validation_report",  "runs_compared",  "collation_agent",  ])
        self._props = CollationMetadataProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CollationMetadataProperties":
        return self._props


class CollationMetadataViewer(CollationMetadataAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CollationMetadataProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def collation_timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("collation_timestamp"))
    
    @property
    def run1_timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("run1_timestamp"))
    
    @property
    def run2_timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("run2_timestamp"))
    
    @property
    def validation_report(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("validation_report"))
    
    @property
    def runs_compared(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("runs_compared"))
    
    @property
    def collation_agent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("collation_agent"))
    
    


class CollationResultAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CollationResult")
        self._properties: typing.Set[str] = set([  "collation_complete",  "final_spec_path",  "final_confidence_score",  "total_endpoints",  "endpoints_run1",  "endpoints_run2",  "improvements_count",  "discrepancies_resolved",  "consistency_rate",  "ready_for_scraper_generation",  ])
        self._props = CollationResultProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CollationResultProperties":
        return self._props


class CollationResultViewer(CollationResultAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CollationResultProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def collation_complete(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("collation_complete"))
    
    @property
    def final_spec_path(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("final_spec_path"))
    
    @property
    def final_confidence_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("final_confidence_score"))
    
    @property
    def total_endpoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total_endpoints"))
    
    @property
    def endpoints_run1(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("endpoints_run1"))
    
    @property
    def endpoints_run2(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("endpoints_run2"))
    
    @property
    def improvements_count(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("improvements_count"))
    
    @property
    def discrepancies_resolved(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("discrepancies_resolved"))
    
    @property
    def consistency_rate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("consistency_rate"))
    
    @property
    def ready_for_scraper_generation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("ready_for_scraper_generation"))
    
    


class CriticalGapAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CriticalGap")
        self._properties: typing.Set[str] = set([  "gap_type",  "description",  "action_required",  "discovered",  "documented",  "missing",  ])
        self._props = CriticalGapProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CriticalGapProperties":
        return self._props


class CriticalGapViewer(CriticalGapAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CriticalGapProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def gap_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("gap_type"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def action_required(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action_required"))
    
    @property
    def discovered(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("discovered"))
    
    @property
    def documented(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("documented"))
    
    @property
    def missing(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("missing"))
    
    


class DataCatalogAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DataCatalog")
        self._properties: typing.Set[str] = set([  "total_files_discovered",  "total_endpoints",  "file_formats",  "data_categories",  "downloadable_files",  ])
        self._props = DataCatalogProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DataCatalogProperties":
        return self._props


class DataCatalogViewer(DataCatalogAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DataCatalogProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def total_files_discovered(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total_files_discovered"))
    
    @property
    def total_endpoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total_endpoints"))
    
    @property
    def file_formats(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("file_formats"))
    
    @property
    def data_categories(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_categories"))
    
    @property
    def downloadable_files(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("downloadable_files"))
    
    


class DataInventoryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DataInventory")
        self._properties: typing.Set[str] = set([  "total_files",  "file_formats",  "categories",  "download_links",  ])
        self._props = DataInventoryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DataInventoryProperties":
        return self._props


class DataInventoryViewer(DataInventoryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DataInventoryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def total_files(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total_files"))
    
    @property
    def file_formats(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("file_formats"))
    
    @property
    def categories(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("categories"))
    
    @property
    def download_links(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("download_links"))
    
    


class DiscrepancyAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Discrepancy")
        self._properties: typing.Set[str] = set([  "type",  "documentation_said",  "api_testing_showed",  "severity",  "resolution",  "area",  "phase1_claim",  "phase2_finding",  ])
        self._props = DiscrepancyProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DiscrepancyProperties":
        return self._props


class DiscrepancyViewer(DiscrepancyAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DiscrepancyProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def documentation_said(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("documentation_said"))
    
    @property
    def api_testing_showed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("api_testing_showed"))
    
    @property
    def severity(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("severity"))
    
    @property
    def resolution(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("resolution"))
    
    @property
    def area(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("area"))
    
    @property
    def phase1_claim(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phase1_claim"))
    
    @property
    def phase2_finding(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phase2_finding"))
    
    


class DownloadTestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DownloadTest")
        self._properties: typing.Set[str] = set([  "url",  "http_status",  "content_type",  "content_length",  "last_modified",  "accessible",  "requires_auth",  "redirect_to_login",  ])
        self._props = DownloadTestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DownloadTestProperties":
        return self._props


class DownloadTestViewer(DownloadTestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DownloadTestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("url"))
    
    @property
    def http_status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("http_status"))
    
    @property
    def content_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content_type"))
    
    @property
    def content_length(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content_length"))
    
    @property
    def last_modified(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("last_modified"))
    
    @property
    def accessible(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("accessible"))
    
    @property
    def requires_auth(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("requires_auth"))
    
    @property
    def redirect_to_login(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("redirect_to_login"))
    
    


class EndpointAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Endpoint")
        self._properties: typing.Set[str] = set([  "path",  "method",  "parameters",  "auth_required",  "response_format",  ])
        self._props = EndpointProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EndpointProperties":
        return self._props


class EndpointViewer(EndpointAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class EndpointProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def path(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("path"))
    
    @property
    def method(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("method"))
    
    @property
    def parameters(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("parameters"))
    
    @property
    def auth_required(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("auth_required"))
    
    @property
    def response_format(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("response_format"))
    
    


class EndpointDetailsAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("EndpointDetails")
        self._properties: typing.Set[str] = set([  "endpoint_id",  "name",  "type",  "base_url",  "path",  "method",  "parameters",  "authentication",  "response_format",  "data_structure",  "sample_files",  "validation_status",  "accessible",  "last_tested",  "file_count",  "update_frequency",  "notes",  "validation_consistency",  "tested_in_run1",  "tested_in_run2",  ])
        self._props = EndpointDetailsProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EndpointDetailsProperties":
        return self._props


class EndpointDetailsViewer(EndpointDetailsAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class EndpointDetailsProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def endpoint_id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("endpoint_id"))
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def base_url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("base_url"))
    
    @property
    def path(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("path"))
    
    @property
    def method(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("method"))
    
    @property
    def parameters(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("parameters"))
    
    @property
    def authentication(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authentication"))
    
    @property
    def response_format(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("response_format"))
    
    @property
    def data_structure(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_structure"))
    
    @property
    def sample_files(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sample_files"))
    
    @property
    def validation_status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("validation_status"))
    
    @property
    def accessible(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("accessible"))
    
    @property
    def last_tested(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("last_tested"))
    
    @property
    def file_count(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("file_count"))
    
    @property
    def update_frequency(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("update_frequency"))
    
    @property
    def notes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("notes"))
    
    @property
    def validation_consistency(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("validation_consistency"))
    
    @property
    def tested_in_run1(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tested_in_run1"))
    
    @property
    def tested_in_run2(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tested_in_run2"))
    
    


class EndpointDiscoveryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("EndpointDiscovery")
        self._properties: typing.Set[str] = set([  "total_endpoints_found",  "collapsible_sections_expanded",  "extraction_method",  "screenshot_taken",  "systematic_enumeration_completed",  ])
        self._props = EndpointDiscoveryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EndpointDiscoveryProperties":
        return self._props


class EndpointDiscoveryViewer(EndpointDiscoveryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class EndpointDiscoveryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def total_endpoints_found(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total_endpoints_found"))
    
    @property
    def collapsible_sections_expanded(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("collapsible_sections_expanded"))
    
    @property
    def extraction_method(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("extraction_method"))
    
    @property
    def screenshot_taken(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("screenshot_taken"))
    
    @property
    def systematic_enumeration_completed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("systematic_enumeration_completed"))
    
    


class EndpointSpecAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("EndpointSpec")
        self._properties: typing.Set[str] = set([  "endpoint_id",  "path",  "method",  "description",  "parameters",  "response_format",  "authentication_mentioned",  ])
        self._props = EndpointSpecProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EndpointSpecProperties":
        return self._props


class EndpointSpecViewer(EndpointSpecAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class EndpointSpecProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def endpoint_id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("endpoint_id"))
    
    @property
    def path(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("path"))
    
    @property
    def method(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("method"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def parameters(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("parameters"))
    
    @property
    def response_format(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("response_format"))
    
    @property
    def authentication_mentioned(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authentication_mentioned"))
    
    


class ExecutiveSummaryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ExecutiveSummary")
        self._properties: typing.Set[str] = set([  "total_endpoints_discovered",  "total_datasets",  "total_files",  "accessible_endpoints",  "protected_endpoints",  "broken_endpoints",  "success_rate",  "primary_formats",  "authentication_required",  "estimated_scraper_complexity",  "improvements_from_run1",  ])
        self._props = ExecutiveSummaryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ExecutiveSummaryProperties":
        return self._props


class ExecutiveSummaryViewer(ExecutiveSummaryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ExecutiveSummaryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def total_endpoints_discovered(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total_endpoints_discovered"))
    
    @property
    def total_datasets(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total_datasets"))
    
    @property
    def total_files(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total_files"))
    
    @property
    def accessible_endpoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("accessible_endpoints"))
    
    @property
    def protected_endpoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("protected_endpoints"))
    
    @property
    def broken_endpoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("broken_endpoints"))
    
    @property
    def success_rate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success_rate"))
    
    @property
    def primary_formats(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("primary_formats"))
    
    @property
    def authentication_required(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authentication_required"))
    
    @property
    def estimated_scraper_complexity(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("estimated_scraper_complexity"))
    
    @property
    def improvements_from_run1(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("improvements_from_run1"))
    
    


class FileMetadataVerificationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FileMetadataVerification")
        self._properties: typing.Set[str] = set([  "file_sizes_match_claims",  "content_types_match",  "last_modified_dates_available",  ])
        self._props = FileMetadataVerificationProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FileMetadataVerificationProperties":
        return self._props


class FileMetadataVerificationViewer(FileMetadataVerificationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class FileMetadataVerificationProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def file_sizes_match_claims(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("file_sizes_match_claims"))
    
    @property
    def content_types_match(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content_types_match"))
    
    @property
    def last_modified_dates_available(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("last_modified_dates_available"))
    
    


class ParameterAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Parameter")
        self._properties: typing.Set[str] = set([  "name",  "type",  "required",  "description",  "example",  ])
        self._props = ParameterProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ParameterProperties":
        return self._props


class ParameterViewer(ParameterAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ParameterProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def required(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("required"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def example(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("example"))
    
    


class Phase0DetectionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Phase0Detection")
        self._properties: typing.Set[str] = set([  "detected_type",  "confidence",  "indicators",  "discovered_api_calls",  "endpoints",  "url",  "fallback_strategy",  ])
        self._props = Phase0DetectionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "Phase0DetectionProperties":
        return self._props


class Phase0DetectionViewer(Phase0DetectionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class Phase0DetectionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def detected_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("detected_type"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    @property
    def indicators(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("indicators"))
    
    @property
    def discovered_api_calls(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("discovered_api_calls"))
    
    @property
    def endpoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("endpoints"))
    
    @property
    def url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("url"))
    
    @property
    def fallback_strategy(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("fallback_strategy"))
    
    


class Phase1DocumentationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Phase1Documentation")
        self._properties: typing.Set[str] = set([  "source",  "timestamp",  "url",  "endpoint_discovery",  "auth_claims",  "endpoints",  "doc_quality",  "notes",  "source_type",  "data_inventory",  "access_requirements",  "update_frequency",  "portal_type",  "extraction_quality",  ])
        self._props = Phase1DocumentationProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "Phase1DocumentationProperties":
        return self._props


class Phase1DocumentationViewer(Phase1DocumentationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class Phase1DocumentationProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def source(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source"))
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    @property
    def url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("url"))
    
    @property
    def endpoint_discovery(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("endpoint_discovery"))
    
    @property
    def auth_claims(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("auth_claims"))
    
    @property
    def endpoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("endpoints"))
    
    @property
    def doc_quality(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("doc_quality"))
    
    @property
    def notes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("notes"))
    
    @property
    def source_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source_type"))
    
    @property
    def data_inventory(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_inventory"))
    
    @property
    def access_requirements(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("access_requirements"))
    
    @property
    def update_frequency(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("update_frequency"))
    
    @property
    def portal_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("portal_type"))
    
    @property
    def extraction_quality(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("extraction_quality"))
    
    


class Phase2TestsAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Phase2Tests")
        self._properties: typing.Set[str] = set([  "source",  "timestamp",  "endpoint_tested",  "test_results",  "conclusion",  "files_saved",  "source_type",  "download_tests",  "authentication_findings",  "file_metadata_verification",  "portal_type",  "portal_conclusion",  ])
        self._props = Phase2TestsProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "Phase2TestsProperties":
        return self._props


class Phase2TestsViewer(Phase2TestsAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class Phase2TestsProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def source(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source"))
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    @property
    def endpoint_tested(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("endpoint_tested"))
    
    @property
    def test_results(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("test_results"))
    
    @property
    def conclusion(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("conclusion"))
    
    @property
    def files_saved(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("files_saved"))
    
    @property
    def source_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source_type"))
    
    @property
    def download_tests(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("download_tests"))
    
    @property
    def authentication_findings(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authentication_findings"))
    
    @property
    def file_metadata_verification(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("file_metadata_verification"))
    
    @property
    def portal_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("portal_type"))
    
    @property
    def portal_conclusion(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("portal_conclusion"))
    
    


class PhaseValidationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PhaseValidation")
        self._properties: typing.Set[str] = set([  "status",  "issues",  "notes",  ])
        self._props = PhaseValidationProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PhaseValidationProperties":
        return self._props


class PhaseValidationViewer(PhaseValidationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class PhaseValidationProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def issues(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("issues"))
    
    @property
    def notes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("notes"))
    
    


class ScraperRecommendationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ScraperRecommendation")
        self._properties: typing.Set[str] = set([  "type",  "confidence",  "rationale",  "complexity",  "estimated_effort",  "key_challenges",  ])
        self._props = ScraperRecommendationProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ScraperRecommendationProperties":
        return self._props


class ScraperRecommendationViewer(ScraperRecommendationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ScraperRecommendationProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    @property
    def rationale(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("rationale"))
    
    @property
    def complexity(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("complexity"))
    
    @property
    def estimated_effort(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("estimated_effort"))
    
    @property
    def key_challenges(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("key_challenges"))
    
    


class TestConclusionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TestConclusion")
        self._properties: typing.Set[str] = set([  "auth_required",  "evidence",  "likely_auth_method",  "likely_header_name",  "confidence",  ])
        self._props = TestConclusionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TestConclusionProperties":
        return self._props


class TestConclusionViewer(TestConclusionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class TestConclusionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def auth_required(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("auth_required"))
    
    @property
    def evidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("evidence"))
    
    @property
    def likely_auth_method(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("likely_auth_method"))
    
    @property
    def likely_header_name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("likely_header_name"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    


class TestResultAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TestResult")
        self._properties: typing.Set[str] = set([  "http_status",  "response_snippet",  "auth_keywords_found",  "full_output_file",  ])
        self._props = TestResultProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TestResultProperties":
        return self._props


class TestResultViewer(TestResultAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class TestResultProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def http_status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("http_status"))
    
    @property
    def response_snippet(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("response_snippet"))
    
    @property
    def auth_keywords_found(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("auth_keywords_found"))
    
    @property
    def full_output_file(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("full_output_file"))
    
    


class ValidatedSpecAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ValidatedSpec")
        self._properties: typing.Set[str] = set([  "source",  "source_type",  "timestamp",  "url",  "executive_summary",  "validation_summary",  "authentication",  "access_requirements",  "endpoints",  "data_catalog",  "scraper_recommendation",  "discrepancies",  "artifacts_generated",  "next_steps",  "collation_metadata",  "collation_analysis",  ])
        self._props = ValidatedSpecProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ValidatedSpecProperties":
        return self._props


class ValidatedSpecViewer(ValidatedSpecAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ValidatedSpecProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def source(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source"))
    
    @property
    def source_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source_type"))
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    @property
    def url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("url"))
    
    @property
    def executive_summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("executive_summary"))
    
    @property
    def validation_summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("validation_summary"))
    
    @property
    def authentication(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authentication"))
    
    @property
    def access_requirements(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("access_requirements"))
    
    @property
    def endpoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("endpoints"))
    
    @property
    def data_catalog(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data_catalog"))
    
    @property
    def scraper_recommendation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scraper_recommendation"))
    
    @property
    def discrepancies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("discrepancies"))
    
    @property
    def artifacts_generated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("artifacts_generated"))
    
    @property
    def next_steps(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("next_steps"))
    
    @property
    def collation_metadata(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("collation_metadata"))
    
    @property
    def collation_analysis(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("collation_analysis"))
    
    


class ValidationReportAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ValidationReport")
        self._properties: typing.Set[str] = set([  "validation_timestamp",  "input_file",  "overall_status",  "overall_confidence",  "phase_validations",  "critical_gaps",  "recommendations_for_second_pass",  "validation_summary",  ])
        self._props = ValidationReportProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ValidationReportProperties":
        return self._props


class ValidationReportViewer(ValidationReportAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ValidationReportProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def validation_timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("validation_timestamp"))
    
    @property
    def input_file(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("input_file"))
    
    @property
    def overall_status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overall_status"))
    
    @property
    def overall_confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overall_confidence"))
    
    @property
    def phase_validations(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phase_validations"))
    
    @property
    def critical_gaps(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("critical_gaps"))
    
    @property
    def recommendations_for_second_pass(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommendations_for_second_pass"))
    
    @property
    def validation_summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("validation_summary"))
    
    


class ValidationResultAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ValidationResult")
        self._properties: typing.Set[str] = set([  "confidence",  "identified_gaps",  "recommendations",  "validation_notes",  ])
        self._props = ValidationResultProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ValidationResultProperties":
        return self._props


class ValidationResultViewer(ValidationResultAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ValidationResultProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    @property
    def identified_gaps(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("identified_gaps"))
    
    @property
    def recommendations(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommendations"))
    
    @property
    def validation_notes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("validation_notes"))
    
    


class ValidationSummaryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ValidationSummary")
        self._properties: typing.Set[str] = set([  "phases_completed",  "documentation_review",  "live_api_testing",  "discrepancies_found",  "confidence_score",  "confidence_level",  "recommendation",  "collation_complete",  "runs_analyzed",  "final_confidence_score",  "run1_confidence",  "run2_confidence",  "confidence_consistency",  "validator_status",  "discrepancies_resolved",  ])
        self._props = ValidationSummaryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ValidationSummaryProperties":
        return self._props


class ValidationSummaryViewer(ValidationSummaryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ValidationSummaryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def phases_completed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phases_completed"))
    
    @property
    def documentation_review(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("documentation_review"))
    
    @property
    def live_api_testing(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("live_api_testing"))
    
    @property
    def discrepancies_found(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("discrepancies_found"))
    
    @property
    def confidence_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence_score"))
    
    @property
    def confidence_level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence_level"))
    
    @property
    def recommendation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommendation"))
    
    @property
    def collation_complete(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("collation_complete"))
    
    @property
    def runs_analyzed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("runs_analyzed"))
    
    @property
    def final_confidence_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("final_confidence_score"))
    
    @property
    def run1_confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("run1_confidence"))
    
    @property
    def run2_confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("run2_confidence"))
    
    @property
    def confidence_consistency(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence_consistency"))
    
    @property
    def validator_status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("validator_status"))
    
    @property
    def discrepancies_resolved(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("discrepancies_resolved"))
    
    

