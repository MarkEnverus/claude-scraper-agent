/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import { FieldType } from '@boundaryml/baml/native'
import { TypeBuilder as _TypeBuilder, EnumBuilder, EnumViewer, ClassBuilder, ClassViewer } from '@boundaryml/baml/type_builder'
import { DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME } from "./globals"

export { FieldType, EnumBuilder, ClassBuilder }

export default class TypeBuilder {
    private tb: _TypeBuilder;
    
    AccessRequirements: ClassViewer<'AccessRequirements', "authentication" | "registration" | "terms_of_use_url" | "subscription_required" | "rate_limits">;
    
    AuthClaims: ClassViewer<'AuthClaims', "auth_section_found" | "auth_section_text" | "signup_links" | "api_key_mentioned" | "subscription_mentioned" | "auth_header_examples" | "conclusion">;
    
    AuthenticationFindings: ClassViewer<'AuthenticationFindings', "auth_required" | "evidence" | "cookie_required" | "redirect_to_login" | "auth_headers_found">;
    
    AuthenticationSpec: ClassViewer<'AuthenticationSpec', "required" | "method" | "header_name" | "evidence" | "registration_url" | "notes" | "authentication_consistency" | "authentication_notes" | "authentication_details">;
    
    CollationAnalysis: ClassViewer<'CollationAnalysis', "run_comparison" | "improvements_from_run2" | "discrepancies_resolved" | "consistency_checks">;
    
    CollationMetadata: ClassViewer<'CollationMetadata', "collation_timestamp" | "run1_timestamp" | "run2_timestamp" | "validation_report" | "runs_compared" | "collation_agent">;
    
    CollationResult: ClassViewer<'CollationResult', "collation_complete" | "final_spec_path" | "final_confidence_score" | "total_endpoints" | "endpoints_run1" | "endpoints_run2" | "improvements_count" | "discrepancies_resolved" | "consistency_rate" | "ready_for_scraper_generation">;
    
    CriticalGap: ClassViewer<'CriticalGap', "gap_type" | "description" | "action_required" | "discovered" | "documented" | "missing">;
    
    DataCatalog: ClassViewer<'DataCatalog', "total_files_discovered" | "total_endpoints" | "file_formats" | "data_categories" | "downloadable_files">;
    
    DataInventory: ClassViewer<'DataInventory', "total_files" | "file_formats" | "categories" | "download_links">;
    
    Discrepancy: ClassViewer<'Discrepancy', "type" | "documentation_said" | "api_testing_showed" | "severity" | "resolution" | "area" | "phase1_claim" | "phase2_finding">;
    
    DownloadTest: ClassViewer<'DownloadTest', "url" | "http_status" | "content_type" | "content_length" | "last_modified" | "accessible" | "requires_auth" | "redirect_to_login">;
    
    Endpoint: ClassViewer<'Endpoint', "path" | "method" | "parameters" | "auth_required" | "response_format">;
    
    EndpointDetails: ClassViewer<'EndpointDetails', "endpoint_id" | "name" | "type" | "base_url" | "path" | "method" | "parameters" | "authentication" | "response_format" | "data_structure" | "sample_files" | "validation_status" | "accessible" | "last_tested" | "file_count" | "update_frequency" | "notes" | "validation_consistency" | "tested_in_run1" | "tested_in_run2">;
    
    EndpointDiscovery: ClassViewer<'EndpointDiscovery', "total_endpoints_found" | "collapsible_sections_expanded" | "extraction_method" | "screenshot_taken" | "systematic_enumeration_completed">;
    
    EndpointSpec: ClassViewer<'EndpointSpec', "endpoint_id" | "path" | "method" | "description" | "parameters" | "response_format" | "authentication_mentioned">;
    
    ExecutiveSummary: ClassViewer<'ExecutiveSummary', "total_endpoints_discovered" | "total_datasets" | "total_files" | "accessible_endpoints" | "protected_endpoints" | "broken_endpoints" | "success_rate" | "primary_formats" | "authentication_required" | "estimated_scraper_complexity" | "improvements_from_run1">;
    
    FileMetadataVerification: ClassViewer<'FileMetadataVerification', "file_sizes_match_claims" | "content_types_match" | "last_modified_dates_available">;
    
    Parameter: ClassViewer<'Parameter', "name" | "type" | "required" | "description" | "example">;
    
    Phase0Detection: ClassViewer<'Phase0Detection', "detected_type" | "confidence" | "indicators" | "discovered_api_calls" | "endpoints" | "url" | "fallback_strategy">;
    
    Phase1Documentation: ClassViewer<'Phase1Documentation', "source" | "timestamp" | "url" | "endpoint_discovery" | "auth_claims" | "endpoints" | "doc_quality" | "notes" | "source_type" | "data_inventory" | "access_requirements" | "update_frequency" | "portal_type" | "extraction_quality">;
    
    Phase2Tests: ClassViewer<'Phase2Tests', "source" | "timestamp" | "endpoint_tested" | "test_results" | "conclusion" | "files_saved" | "source_type" | "download_tests" | "authentication_findings" | "file_metadata_verification">;
    
    PhaseValidation: ClassViewer<'PhaseValidation', "status" | "issues" | "notes">;
    
    ScraperRecommendation: ClassViewer<'ScraperRecommendation', "type" | "confidence" | "rationale" | "complexity" | "estimated_effort" | "key_challenges">;
    
    TestConclusion: ClassViewer<'TestConclusion', "auth_required" | "evidence" | "likely_auth_method" | "likely_header_name" | "confidence">;
    
    TestResult: ClassViewer<'TestResult', "http_status" | "response_snippet" | "auth_keywords_found" | "full_output_file">;
    
    ValidatedSpec: ClassViewer<'ValidatedSpec', "source" | "source_type" | "timestamp" | "url" | "executive_summary" | "validation_summary" | "authentication" | "access_requirements" | "endpoints" | "data_catalog" | "scraper_recommendation" | "discrepancies" | "artifacts_generated" | "next_steps" | "collation_metadata" | "collation_analysis">;
    
    ValidationReport: ClassViewer<'ValidationReport', "validation_timestamp" | "input_file" | "overall_status" | "overall_confidence" | "phase_validations" | "critical_gaps" | "recommendations_for_second_pass" | "validation_summary">;
    
    ValidationSummary: ClassViewer<'ValidationSummary', "phases_completed" | "documentation_review" | "live_api_testing" | "discrepancies_found" | "confidence_score" | "confidence_level" | "recommendation" | "collation_complete" | "runs_analyzed" | "final_confidence_score" | "run1_confidence" | "run2_confidence" | "confidence_consistency" | "validator_status" | "discrepancies_resolved">;
    
    
    AuthenticationMethod: EnumViewer<'AuthenticationMethod', "NONE" | "API_KEY" | "BEARER_TOKEN" | "OAUTH" | "BASIC_AUTH" | "COOKIE" | "UNKNOWN">;
    
    ComplexityLevel: EnumViewer<'ComplexityLevel', "LOW" | "MEDIUM" | "HIGH">;
    
    ConfidenceLevel: EnumViewer<'ConfidenceLevel', "HIGH" | "MEDIUM" | "LOW">;
    
    DataSourceType: EnumViewer<'DataSourceType', "API" | "FTP" | "WEBSITE" | "EMAIL">;
    
    ExtractionQuality: EnumViewer<'ExtractionQuality', "COMPREHENSIVE" | "PARTIAL" | "LIMITED" | "MISSING">;
    
    HTTPMethod: EnumViewer<'HTTPMethod', "GET" | "POST" | "PUT" | "DELETE" | "PATCH" | "HEAD" | "OPTIONS">;
    
    ScraperType: EnumViewer<'ScraperType', "WEBSITE_PARSER" | "HTTP_COLLECTOR" | "API_CLIENT" | "FTP_CLIENT">;
    
    ValidationOverallStatus: EnumViewer<'ValidationOverallStatus', "PASS" | "NEEDS_IMPROVEMENT" | "FAIL">;
    
    ValidationStatus: EnumViewer<'ValidationStatus', "TESTED_200_OK" | "TESTED_401_UNAUTHORIZED" | "TESTED_403_FORBIDDEN" | "TESTED_404_NOT_FOUND" | "NOT_TESTED">;
    

    constructor() {
        this.tb = new _TypeBuilder({
          classes: new Set([
            "AccessRequirements","AuthClaims","AuthenticationFindings","AuthenticationSpec","CollationAnalysis","CollationMetadata","CollationResult","CriticalGap","DataCatalog","DataInventory","Discrepancy","DownloadTest","Endpoint","EndpointDetails","EndpointDiscovery","EndpointSpec","ExecutiveSummary","FileMetadataVerification","Parameter","Phase0Detection","Phase1Documentation","Phase2Tests","PhaseValidation","ScraperRecommendation","TestConclusion","TestResult","ValidatedSpec","ValidationReport","ValidationSummary",
          ]),
          enums: new Set([
            "AuthenticationMethod","ComplexityLevel","ConfidenceLevel","DataSourceType","ExtractionQuality","HTTPMethod","ScraperType","ValidationOverallStatus","ValidationStatus",
          ]),
          runtime: DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME
        });
        
        this.AccessRequirements = this.tb.classViewer("AccessRequirements", [
          "authentication","registration","terms_of_use_url","subscription_required","rate_limits",
        ]);
        
        this.AuthClaims = this.tb.classViewer("AuthClaims", [
          "auth_section_found","auth_section_text","signup_links","api_key_mentioned","subscription_mentioned","auth_header_examples","conclusion",
        ]);
        
        this.AuthenticationFindings = this.tb.classViewer("AuthenticationFindings", [
          "auth_required","evidence","cookie_required","redirect_to_login","auth_headers_found",
        ]);
        
        this.AuthenticationSpec = this.tb.classViewer("AuthenticationSpec", [
          "required","method","header_name","evidence","registration_url","notes","authentication_consistency","authentication_notes","authentication_details",
        ]);
        
        this.CollationAnalysis = this.tb.classViewer("CollationAnalysis", [
          "run_comparison","improvements_from_run2","discrepancies_resolved","consistency_checks",
        ]);
        
        this.CollationMetadata = this.tb.classViewer("CollationMetadata", [
          "collation_timestamp","run1_timestamp","run2_timestamp","validation_report","runs_compared","collation_agent",
        ]);
        
        this.CollationResult = this.tb.classViewer("CollationResult", [
          "collation_complete","final_spec_path","final_confidence_score","total_endpoints","endpoints_run1","endpoints_run2","improvements_count","discrepancies_resolved","consistency_rate","ready_for_scraper_generation",
        ]);
        
        this.CriticalGap = this.tb.classViewer("CriticalGap", [
          "gap_type","description","action_required","discovered","documented","missing",
        ]);
        
        this.DataCatalog = this.tb.classViewer("DataCatalog", [
          "total_files_discovered","total_endpoints","file_formats","data_categories","downloadable_files",
        ]);
        
        this.DataInventory = this.tb.classViewer("DataInventory", [
          "total_files","file_formats","categories","download_links",
        ]);
        
        this.Discrepancy = this.tb.classViewer("Discrepancy", [
          "type","documentation_said","api_testing_showed","severity","resolution","area","phase1_claim","phase2_finding",
        ]);
        
        this.DownloadTest = this.tb.classViewer("DownloadTest", [
          "url","http_status","content_type","content_length","last_modified","accessible","requires_auth","redirect_to_login",
        ]);
        
        this.Endpoint = this.tb.classViewer("Endpoint", [
          "path","method","parameters","auth_required","response_format",
        ]);
        
        this.EndpointDetails = this.tb.classViewer("EndpointDetails", [
          "endpoint_id","name","type","base_url","path","method","parameters","authentication","response_format","data_structure","sample_files","validation_status","accessible","last_tested","file_count","update_frequency","notes","validation_consistency","tested_in_run1","tested_in_run2",
        ]);
        
        this.EndpointDiscovery = this.tb.classViewer("EndpointDiscovery", [
          "total_endpoints_found","collapsible_sections_expanded","extraction_method","screenshot_taken","systematic_enumeration_completed",
        ]);
        
        this.EndpointSpec = this.tb.classViewer("EndpointSpec", [
          "endpoint_id","path","method","description","parameters","response_format","authentication_mentioned",
        ]);
        
        this.ExecutiveSummary = this.tb.classViewer("ExecutiveSummary", [
          "total_endpoints_discovered","total_datasets","total_files","accessible_endpoints","protected_endpoints","broken_endpoints","success_rate","primary_formats","authentication_required","estimated_scraper_complexity","improvements_from_run1",
        ]);
        
        this.FileMetadataVerification = this.tb.classViewer("FileMetadataVerification", [
          "file_sizes_match_claims","content_types_match","last_modified_dates_available",
        ]);
        
        this.Parameter = this.tb.classViewer("Parameter", [
          "name","type","required","description","example",
        ]);
        
        this.Phase0Detection = this.tb.classViewer("Phase0Detection", [
          "detected_type","confidence","indicators","discovered_api_calls","endpoints","url","fallback_strategy",
        ]);
        
        this.Phase1Documentation = this.tb.classViewer("Phase1Documentation", [
          "source","timestamp","url","endpoint_discovery","auth_claims","endpoints","doc_quality","notes","source_type","data_inventory","access_requirements","update_frequency","portal_type","extraction_quality",
        ]);
        
        this.Phase2Tests = this.tb.classViewer("Phase2Tests", [
          "source","timestamp","endpoint_tested","test_results","conclusion","files_saved","source_type","download_tests","authentication_findings","file_metadata_verification",
        ]);
        
        this.PhaseValidation = this.tb.classViewer("PhaseValidation", [
          "status","issues","notes",
        ]);
        
        this.ScraperRecommendation = this.tb.classViewer("ScraperRecommendation", [
          "type","confidence","rationale","complexity","estimated_effort","key_challenges",
        ]);
        
        this.TestConclusion = this.tb.classViewer("TestConclusion", [
          "auth_required","evidence","likely_auth_method","likely_header_name","confidence",
        ]);
        
        this.TestResult = this.tb.classViewer("TestResult", [
          "http_status","response_snippet","auth_keywords_found","full_output_file",
        ]);
        
        this.ValidatedSpec = this.tb.classViewer("ValidatedSpec", [
          "source","source_type","timestamp","url","executive_summary","validation_summary","authentication","access_requirements","endpoints","data_catalog","scraper_recommendation","discrepancies","artifacts_generated","next_steps","collation_metadata","collation_analysis",
        ]);
        
        this.ValidationReport = this.tb.classViewer("ValidationReport", [
          "validation_timestamp","input_file","overall_status","overall_confidence","phase_validations","critical_gaps","recommendations_for_second_pass","validation_summary",
        ]);
        
        this.ValidationSummary = this.tb.classViewer("ValidationSummary", [
          "phases_completed","documentation_review","live_api_testing","discrepancies_found","confidence_score","confidence_level","recommendation","collation_complete","runs_analyzed","final_confidence_score","run1_confidence","run2_confidence","confidence_consistency","validator_status","discrepancies_resolved",
        ]);
        
        
        this.AuthenticationMethod = this.tb.enumViewer("AuthenticationMethod", [
          "NONE","API_KEY","BEARER_TOKEN","OAUTH","BASIC_AUTH","COOKIE","UNKNOWN",
        ]);
        
        this.ComplexityLevel = this.tb.enumViewer("ComplexityLevel", [
          "LOW","MEDIUM","HIGH",
        ]);
        
        this.ConfidenceLevel = this.tb.enumViewer("ConfidenceLevel", [
          "HIGH","MEDIUM","LOW",
        ]);
        
        this.DataSourceType = this.tb.enumViewer("DataSourceType", [
          "API","FTP","WEBSITE","EMAIL",
        ]);
        
        this.ExtractionQuality = this.tb.enumViewer("ExtractionQuality", [
          "COMPREHENSIVE","PARTIAL","LIMITED","MISSING",
        ]);
        
        this.HTTPMethod = this.tb.enumViewer("HTTPMethod", [
          "GET","POST","PUT","DELETE","PATCH","HEAD","OPTIONS",
        ]);
        
        this.ScraperType = this.tb.enumViewer("ScraperType", [
          "WEBSITE_PARSER","HTTP_COLLECTOR","API_CLIENT","FTP_CLIENT",
        ]);
        
        this.ValidationOverallStatus = this.tb.enumViewer("ValidationOverallStatus", [
          "PASS","NEEDS_IMPROVEMENT","FAIL",
        ]);
        
        this.ValidationStatus = this.tb.enumViewer("ValidationStatus", [
          "TESTED_200_OK","TESTED_401_UNAUTHORIZED","TESTED_403_FORBIDDEN","TESTED_404_NOT_FOUND","NOT_TESTED",
        ]);
        
    }

    reset(): void {
        this.tb.reset();
        // TODO: This should happen in Rust. Problem is, when we construct the
        // typebuilder we instantiate class builders once and it seems to make
        // a JS copy, bypassing the Rust side? In Python however, every time we
        // access a class builder with @property, we get a new instance that
        // wraps over the Rust type builder, so we only need to call tb.reset().
        // In JS it's not possible unless we refactor the way class builders are
        // accessed.
        
    }

    __tb() {
      return this.tb._tb();
    }

    string(): FieldType {
        return this.tb.string()
    }

    literalString(value: string): FieldType {
        return this.tb.literalString(value)
    }

    literalInt(value: number): FieldType {
        return this.tb.literalInt(value)
    }

    literalBool(value: boolean): FieldType {
        return this.tb.literalBool(value)
    }

    int(): FieldType {
        return this.tb.int()
    }

    float(): FieldType {
        return this.tb.float()
    }

    bool(): FieldType {
        return this.tb.bool()
    }

    list(type: FieldType): FieldType {
        return this.tb.list(type)
    }

    null(): FieldType {
        return this.tb.null()
    }

    map(key: FieldType, value: FieldType): FieldType {
        return this.tb.map(key, value)
    }

    union(types: FieldType[]): FieldType {
        return this.tb.union(types)
    }

    addClass<Name extends string>(name: Name): ClassBuilder<Name> {
        return this.tb.addClass(name);
    }

    addEnum<Name extends string>(name: Name): EnumBuilder<Name> {
        return this.tb.addEnum(name);
    }

    addBaml(baml: string): void {
        this.tb.addBaml(baml);
    }
}